{"ast":null,"code":"import _objectSpread from \"C:/xampp/htdocs/quizbm/quizbm-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nclass l {\n  /**\n   * Listen for a whisper event on the channel instance.\n   */\n  listenForWhisper(e, t) {\n    return this.listen(\".client-\" + e, t);\n  }\n  /**\n   * Listen for an event on the channel instance.\n   */\n  notification(e) {\n    return this.listen(\".Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated\", e);\n  }\n  /**\n   * Stop listening for a whisper event on the channel instance.\n   */\n  stopListeningForWhisper(e, t) {\n    return this.stopListening(\".client-\" + e, t);\n  }\n}\nclass d {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e) {\n    this.namespace = e;\n  }\n  /**\n   * Format the given event name.\n   */\n  format(e) {\n    return [\".\", \"\\\\\"].includes(e.charAt(0)) ? e.substring(1) : (this.namespace && (e = this.namespace + \".\" + e), e.replace(/\\./g, \"\\\\\"));\n  }\n  /**\n   * Set the event namespace.\n   */\n  setNamespace(e) {\n    this.namespace = e;\n  }\n}\nfunction w(n) {\n  try {\n    new n();\n  } catch (e) {\n    if (e instanceof Error && e.message.includes(\"is not a constructor\")) return !1;\n  }\n  return !0;\n}\nclass u extends l {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e, t, s) {\n    super(), this.name = t, this.pusher = e, this.options = s, this.eventFormatter = new d(this.options.namespace), this.subscribe();\n  }\n  /**\n   * Subscribe to a Pusher channel.\n   */\n  subscribe() {\n    this.subscription = this.pusher.subscribe(this.name);\n  }\n  /**\n   * Unsubscribe from a Pusher channel.\n   */\n  unsubscribe() {\n    this.pusher.unsubscribe(this.name);\n  }\n  /**\n   * Listen for an event on the channel instance.\n   */\n  listen(e, t) {\n    return this.on(this.eventFormatter.format(e), t), this;\n  }\n  /**\n   * Listen for all events on the channel instance.\n   */\n  listenToAll(e) {\n    return this.subscription.bind_global((t, s) => {\n      var _this$options$namespa;\n      if (t.startsWith(\"pusher:\")) return;\n      let r = String((_this$options$namespa = this.options.namespace) !== null && _this$options$namespa !== void 0 ? _this$options$namespa : \"\").replace(/\\./g, \"\\\\\"),\n        a = t.startsWith(r) ? t.substring(r.length + 1) : \".\" + t;\n      e(a, s);\n    }), this;\n  }\n  /**\n   * Stop listening for an event on the channel instance.\n   */\n  stopListening(e, t) {\n    return t ? this.subscription.unbind(this.eventFormatter.format(e), t) : this.subscription.unbind(this.eventFormatter.format(e)), this;\n  }\n  /**\n   * Stop listening for all events on the channel instance.\n   */\n  stopListeningToAll(e) {\n    return e ? this.subscription.unbind_global(e) : this.subscription.unbind_global(), this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription succeeds.\n   */\n  subscribed(e) {\n    return this.on(\"pusher:subscription_succeeded\", () => {\n      e();\n    }), this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription error occurs.\n   */\n  error(e) {\n    return this.on(\"pusher:subscription_error\", t => {\n      e(t);\n    }), this;\n  }\n  /**\n   * Bind a channel to an event.\n   */\n  on(e, t) {\n    return this.subscription.bind(e, t), this;\n  }\n}\nclass f extends u {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.pusher.channels.channels[this.name].trigger(\"client-\".concat(e), t), this;\n  }\n}\nclass g extends u {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.pusher.channels.channels[this.name].trigger(\"client-\".concat(e), t), this;\n  }\n}\nclass y extends f {\n  /**\n   * Register a callback to be called anytime the member list changes.\n   */\n  here(e) {\n    return this.on(\"pusher:subscription_succeeded\", t => {\n      e(Object.keys(t.members).map(s => t.members[s]));\n    }), this;\n  }\n  /**\n   * Listen for someone joining the channel.\n   */\n  joining(e) {\n    return this.on(\"pusher:member_added\", t => {\n      e(t.info);\n    }), this;\n  }\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.pusher.channels.channels[this.name].trigger(\"client-\".concat(e), t), this;\n  }\n  /**\n   * Listen for someone leaving the channel.\n   */\n  leaving(e) {\n    return this.on(\"pusher:member_removed\", t => {\n      e(t.info);\n    }), this;\n  }\n}\nclass b extends l {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e, t, s) {\n    super(), this.events = {}, this.listeners = {}, this.name = t, this.socket = e, this.options = s, this.eventFormatter = new d(this.options.namespace), this.subscribe();\n  }\n  /**\n   * Subscribe to a Socket.io channel.\n   */\n  subscribe() {\n    this.socket.emit(\"subscribe\", {\n      channel: this.name,\n      auth: this.options.auth || {}\n    });\n  }\n  /**\n   * Unsubscribe from channel and ubind event callbacks.\n   */\n  unsubscribe() {\n    this.unbind(), this.socket.emit(\"unsubscribe\", {\n      channel: this.name,\n      auth: this.options.auth || {}\n    });\n  }\n  /**\n   * Listen for an event on the channel instance.\n   */\n  listen(e, t) {\n    return this.on(this.eventFormatter.format(e), t), this;\n  }\n  /**\n   * Stop listening for an event on the channel instance.\n   */\n  stopListening(e, t) {\n    return this.unbindEvent(this.eventFormatter.format(e), t), this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription succeeds.\n   */\n  subscribed(e) {\n    return this.on(\"connect\", t => {\n      e(t);\n    }), this;\n  }\n  /**\n   * Register a callback to be called anytime an error occurs.\n   */\n  error(e) {\n    return this;\n  }\n  /**\n   * Bind the channel's socket to an event and store the callback.\n   */\n  on(e, t) {\n    return this.listeners[e] = this.listeners[e] || [], this.events[e] || (this.events[e] = (s, r) => {\n      this.name === s && this.listeners[e] && this.listeners[e].forEach(a => a(r));\n    }, this.socket.on(e, this.events[e])), this.listeners[e].push(t), this;\n  }\n  /**\n   * Unbind the channel's socket from all stored event callbacks.\n   */\n  unbind() {\n    Object.keys(this.events).forEach(e => {\n      this.unbindEvent(e);\n    });\n  }\n  /**\n   * Unbind the listeners for the given event.\n   */\n  unbindEvent(e, t) {\n    this.listeners[e] = this.listeners[e] || [], t && (this.listeners[e] = this.listeners[e].filter(s => s !== t)), (!t || this.listeners[e].length === 0) && (this.events[e] && (this.socket.removeListener(e, this.events[e]), delete this.events[e]), delete this.listeners[e]);\n  }\n}\nclass v extends b {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.socket.emit(\"client event\", {\n      channel: this.name,\n      event: \"client-\".concat(e),\n      data: t\n    }), this;\n  }\n}\nclass m extends v {\n  /**\n   * Register a callback to be called anytime the member list changes.\n   */\n  here(e) {\n    return this.on(\"presence:subscribed\", t => {\n      e(t.map(s => s.user_info));\n    }), this;\n  }\n  /**\n   * Listen for someone joining the channel.\n   */\n  joining(e) {\n    return this.on(\"presence:joining\", t => e(t.user_info)), this;\n  }\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.socket.emit(\"client event\", {\n      channel: this.name,\n      event: \"client-\".concat(e),\n      data: t\n    }), this;\n  }\n  /**\n   * Listen for someone leaving the channel.\n   */\n  leaving(e) {\n    return this.on(\"presence:leaving\", t => e(t.user_info)), this;\n  }\n}\nclass h extends l {\n  /**\n   * Subscribe to a channel.\n   */\n  subscribe() {}\n  /**\n   * Unsubscribe from a channel.\n   */\n  unsubscribe() {}\n  /**\n   * Listen for an event on the channel instance.\n   */\n  listen(e, t) {\n    return this;\n  }\n  /**\n   * Listen for all events on the channel instance.\n   */\n  listenToAll(e) {\n    return this;\n  }\n  /**\n   * Stop listening for an event on the channel instance.\n   */\n  stopListening(e, t) {\n    return this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription succeeds.\n   */\n  subscribed(e) {\n    return this;\n  }\n  /**\n   * Register a callback to be called anytime an error occurs.\n   */\n  error(e) {\n    return this;\n  }\n  /**\n   * Bind a channel to an event.\n   */\n  on(e, t) {\n    return this;\n  }\n}\nclass k extends h {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this;\n  }\n}\nclass _ extends h {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this;\n  }\n}\nclass C extends k {\n  /**\n   * Register a callback to be called anytime the member list changes.\n   */\n  here(e) {\n    return this;\n  }\n  /**\n   * Listen for someone joining the channel.\n   */\n  joining(e) {\n    return this;\n  }\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this;\n  }\n  /**\n   * Listen for someone leaving the channel.\n   */\n  leaving(e) {\n    return this;\n  }\n}\nconst c = class c {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e) {\n    this.setOptions(e), this.connect();\n  }\n  /**\n   * Merge the custom options with the defaults.\n   */\n  setOptions(e) {\n    this.options = _objectSpread(_objectSpread(_objectSpread({}, c._defaultOptions), e), {}, {\n      broadcaster: e.broadcaster\n    });\n    let t = this.csrfToken();\n    t && (this.options.auth.headers[\"X-CSRF-TOKEN\"] = t, this.options.userAuthentication.headers[\"X-CSRF-TOKEN\"] = t), t = this.options.bearerToken, t && (this.options.auth.headers.Authorization = \"Bearer \" + t, this.options.userAuthentication.headers.Authorization = \"Bearer \" + t);\n  }\n  /**\n   * Extract the CSRF token from the page.\n   */\n  csrfToken() {\n    var _ref;\n    var e, t;\n    return typeof window < \"u\" && (e = window.Laravel) != null && e.csrfToken ? window.Laravel.csrfToken : this.options.csrfToken ? this.options.csrfToken : typeof document < \"u\" && typeof document.querySelector == \"function\" ? (_ref = (t = document.querySelector('meta[name=\"csrf-token\"]')) == null ? void 0 : t.getAttribute(\"content\")) !== null && _ref !== void 0 ? _ref : null : null;\n  }\n};\nc._defaultOptions = {\n  auth: {\n    headers: {}\n  },\n  authEndpoint: \"/broadcasting/auth\",\n  userAuthentication: {\n    endpoint: \"/broadcasting/user-auth\",\n    headers: {}\n  },\n  csrfToken: null,\n  bearerToken: null,\n  host: null,\n  key: null,\n  namespace: \"App.Events\"\n};\nlet i = c;\nclass o extends i {\n  constructor() {\n    super(...arguments), this.channels = {};\n  }\n  /**\n   * Create a fresh Pusher connection.\n   */\n  connect() {\n    if (typeof this.options.client < \"u\") this.pusher = this.options.client;else if (this.options.Pusher) this.pusher = new this.options.Pusher(this.options.key, this.options);else if (typeof window < \"u\" && typeof window.Pusher < \"u\") this.pusher = new window.Pusher(this.options.key, this.options);else throw new Error(\"Pusher client not found. Should be globally available or passed via options.client\");\n  }\n  /**\n   * Sign in the user via Pusher user authentication (https://pusher.com/docs/channels/using_channels/user-authentication/).\n   */\n  signin() {\n    this.pusher.signin();\n  }\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return this.channel(e).listen(t, s);\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return this.channels[e] || (this.channels[e] = new u(this.pusher, e, this.options)), this.channels[e];\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  privateChannel(e) {\n    return this.channels[\"private-\" + e] || (this.channels[\"private-\" + e] = new f(this.pusher, \"private-\" + e, this.options)), this.channels[\"private-\" + e];\n  }\n  /**\n   * Get a private encrypted channel instance by name.\n   */\n  encryptedPrivateChannel(e) {\n    return this.channels[\"private-encrypted-\" + e] || (this.channels[\"private-encrypted-\" + e] = new g(this.pusher, \"private-encrypted-\" + e, this.options)), this.channels[\"private-encrypted-\" + e];\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  presenceChannel(e) {\n    return this.channels[\"presence-\" + e] || (this.channels[\"presence-\" + e] = new y(this.pusher, \"presence-\" + e, this.options)), this.channels[\"presence-\" + e];\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {\n    [e, \"private-\" + e, \"private-encrypted-\" + e, \"presence-\" + e].forEach(s => {\n      this.leaveChannel(s);\n    });\n  }\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {\n    this.channels[e] && (this.channels[e].unsubscribe(), delete this.channels[e]);\n  }\n  /**\n   * Get the socket ID for the connection.\n   */\n  socketId() {\n    return this.pusher.connection.socket_id;\n  }\n  /**\n   * Disconnect Pusher connection.\n   */\n  disconnect() {\n    this.pusher.disconnect();\n  }\n}\nclass I extends i {\n  constructor() {\n    super(...arguments), this.channels = {};\n  }\n  /**\n   * Create a fresh Socket.io connection.\n   */\n  connect() {\n    var _this$options$host;\n    let e = this.getSocketIO();\n    this.socket = e((_this$options$host = this.options.host) !== null && _this$options$host !== void 0 ? _this$options$host : void 0, this.options), this.socket.io.on(\"reconnect\", () => {\n      Object.values(this.channels).forEach(t => {\n        t.subscribe();\n      });\n    });\n  }\n  /**\n   * Get socket.io module from global scope or options.\n   */\n  getSocketIO() {\n    if (typeof this.options.client < \"u\") return this.options.client;\n    if (typeof window < \"u\" && typeof window.io < \"u\") return window.io;\n    throw new Error(\"Socket.io client not found. Should be globally available or passed via options.client\");\n  }\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return this.channel(e).listen(t, s);\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return this.channels[e] || (this.channels[e] = new b(this.socket, e, this.options)), this.channels[e];\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  privateChannel(e) {\n    return this.channels[\"private-\" + e] || (this.channels[\"private-\" + e] = new v(this.socket, \"private-\" + e, this.options)), this.channels[\"private-\" + e];\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  presenceChannel(e) {\n    return this.channels[\"presence-\" + e] || (this.channels[\"presence-\" + e] = new m(this.socket, \"presence-\" + e, this.options)), this.channels[\"presence-\" + e];\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {\n    [e, \"private-\" + e, \"presence-\" + e].forEach(s => {\n      this.leaveChannel(s);\n    });\n  }\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {\n    this.channels[e] && (this.channels[e].unsubscribe(), delete this.channels[e]);\n  }\n  /**\n   * Get the socket ID for the connection.\n   */\n  socketId() {\n    return this.socket.id;\n  }\n  /**\n   * Disconnect Socketio connection.\n   */\n  disconnect() {\n    this.socket.disconnect();\n  }\n}\nclass p extends i {\n  constructor() {\n    super(...arguments), this.channels = {};\n  }\n  /**\n   * Create a fresh connection.\n   */\n  connect() {}\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return new h();\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return new h();\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  privateChannel(e) {\n    return new k();\n  }\n  /**\n   * Get a private encrypted channel instance by name.\n   */\n  encryptedPrivateChannel(e) {\n    return new _();\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  presenceChannel(e) {\n    return new C();\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {}\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {}\n  /**\n   * Get the socket ID for the connection.\n   */\n  socketId() {\n    return \"fake-socket-id\";\n  }\n  /**\n   * Disconnect the connection.\n   */\n  disconnect() {}\n}\nclass E {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e) {\n    this.options = e, this.connect(), this.options.withoutInterceptors || this.registerInterceptors();\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return this.connector.channel(e);\n  }\n  /**\n   * Create a new connection.\n   */\n  connect() {\n    if (this.options.broadcaster === \"reverb\") this.connector = new o(_objectSpread(_objectSpread({}, this.options), {}, {\n      cluster: \"\"\n    }));else if (this.options.broadcaster === \"pusher\") this.connector = new o(this.options);else if (this.options.broadcaster === \"ably\") this.connector = new o(_objectSpread(_objectSpread({}, this.options), {}, {\n      cluster: \"\",\n      broadcaster: \"pusher\"\n    }));else if (this.options.broadcaster === \"socket.io\") this.connector = new I(this.options);else if (this.options.broadcaster === \"null\") this.connector = new p(this.options);else if (typeof this.options.broadcaster == \"function\" && w(this.options.broadcaster)) this.connector = new this.options.broadcaster(this.options);else throw new Error(\"Broadcaster \".concat(typeof this.options.broadcaster, \" \").concat(String(this.options.broadcaster), \" is not supported.\"));\n  }\n  /**\n   * Disconnect from the Echo server.\n   */\n  disconnect() {\n    this.connector.disconnect();\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  join(e) {\n    return this.connector.presenceChannel(e);\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {\n    this.connector.leave(e);\n  }\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {\n    this.connector.leaveChannel(e);\n  }\n  /**\n   * Leave all channels.\n   */\n  leaveAllChannels() {\n    for (const e in this.connector.channels) this.leaveChannel(e);\n  }\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return this.connector.listen(e, t, s);\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  private(e) {\n    return this.connector.privateChannel(e);\n  }\n  /**\n   * Get a private encrypted channel instance by name.\n   */\n  encryptedPrivate(e) {\n    if (this.connectorSupportsEncryptedPrivateChannels(this.connector)) return this.connector.encryptedPrivateChannel(e);\n    throw new Error(\"Broadcaster \".concat(typeof this.options.broadcaster, \" \").concat(String(this.options.broadcaster), \" does not support encrypted private channels.\"));\n  }\n  connectorSupportsEncryptedPrivateChannels(e) {\n    return e instanceof o || e instanceof p;\n  }\n  /**\n   * Get the Socket ID for the connection.\n   */\n  socketId() {\n    return this.connector.socketId();\n  }\n  /**\n   * Register 3rd party request interceptiors. These are used to automatically\n   * send a connections socket id to a Laravel app with a X-Socket-Id header.\n   */\n  registerInterceptors() {\n    typeof Vue < \"u\" && Vue != null && Vue.http && this.registerVueRequestInterceptor(), typeof axios == \"function\" && this.registerAxiosRequestInterceptor(), typeof jQuery == \"function\" && this.registerjQueryAjaxSetup(), typeof Turbo == \"object\" && this.registerTurboRequestInterceptor();\n  }\n  /**\n   * Register a Vue HTTP interceptor to add the X-Socket-ID header.\n   */\n  registerVueRequestInterceptor() {\n    Vue.http.interceptors.push((e, t) => {\n      this.socketId() && e.headers.set(\"X-Socket-ID\", this.socketId()), t();\n    });\n  }\n  /**\n   * Register an Axios HTTP interceptor to add the X-Socket-ID header.\n   */\n  registerAxiosRequestInterceptor() {\n    axios.interceptors.request.use(e => (this.socketId() && (e.headers[\"X-Socket-Id\"] = this.socketId()), e));\n  }\n  /**\n   * Register jQuery AjaxPrefilter to add the X-Socket-ID header.\n   */\n  registerjQueryAjaxSetup() {\n    typeof jQuery.ajax < \"u\" && jQuery.ajaxPrefilter((e, t, s) => {\n      this.socketId() && s.setRequestHeader(\"X-Socket-Id\", this.socketId());\n    });\n  }\n  /**\n   * Register the Turbo Request interceptor to add the X-Socket-ID header.\n   */\n  registerTurboRequestInterceptor() {\n    document.addEventListener(\"turbo:before-fetch-request\", e => {\n      e.detail.fetchOptions.headers[\"X-Socket-Id\"] = this.socketId();\n    });\n  }\n}\nexport { l as Channel, i as Connector, d as EventFormatter, E as default };","map":{"version":3,"names":["l","listenForWhisper","e","t","listen","notification","stopListeningForWhisper","stopListening","d","constructor","namespace","format","includes","charAt","substring","replace","setNamespace","w","n","Error","message","u","s","name","pusher","options","eventFormatter","subscribe","subscription","unsubscribe","on","listenToAll","bind_global","_this$options$namespa","startsWith","r","String","a","length","unbind","stopListeningToAll","unbind_global","subscribed","error","bind","f","whisper","channels","trigger","concat","g","y","here","Object","keys","members","map","joining","info","leaving","b","events","listeners","socket","emit","channel","auth","unbindEvent","forEach","push","filter","removeListener","v","event","data","m","user_info","h","k","_","C","c","setOptions","connect","_objectSpread","_defaultOptions","broadcaster","csrfToken","headers","userAuthentication","bearerToken","Authorization","_ref","window","Laravel","document","querySelector","getAttribute","authEndpoint","endpoint","host","key","i","o","arguments","client","Pusher","signin","privateChannel","encryptedPrivateChannel","presenceChannel","leave","leaveChannel","socketId","connection","socket_id","disconnect","I","_this$options$host","getSocketIO","io","values","id","p","E","withoutInterceptors","registerInterceptors","connector","cluster","join","leaveAllChannels","private","encryptedPrivate","connectorSupportsEncryptedPrivateChannels","Vue","http","registerVueRequestInterceptor","axios","registerAxiosRequestInterceptor","jQuery","registerjQueryAjaxSetup","Turbo","registerTurboRequestInterceptor","interceptors","set","request","use","ajax","ajaxPrefilter","setRequestHeader","addEventListener","detail","fetchOptions"],"sources":["C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\util\\event-formatter.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\util\\index.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-private-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-encrypted-private-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-presence-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\socketio-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\socketio-private-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\socketio-presence-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-private-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-encrypted-private-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-presence-channel.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\connector.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\pusher-connector.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\socketio-connector.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\null-connector.ts","C:\\xampp\\htdocs\\quizbm\\quizbm-frontend\\node_modules\\laravel-echo\\src\\echo.ts"],"sourcesContent":["import type { EchoOptionsWithDefaults } from \"../connector\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a basic channel.\n */\nexport abstract class Channel {\n    /**\n     * The Echo options.\n     */\n    options: EchoOptionsWithDefaults<BroadcastDriver>;\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    abstract listen(event: string, callback: CallableFunction): this;\n\n    /**\n     * Listen for a whisper event on the channel instance.\n     */\n    listenForWhisper(event: string, callback: CallableFunction): this {\n        return this.listen(\".client-\" + event, callback);\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    notification(callback: CallableFunction): this {\n        return this.listen(\n            \".Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated\",\n            callback,\n        );\n    }\n\n    /**\n     * Stop listening to an event on the channel instance.\n     */\n    abstract stopListening(event: string, callback?: CallableFunction): this;\n\n    /**\n     * Stop listening for a whisper event on the channel instance.\n     */\n    stopListeningForWhisper(event: string, callback?: CallableFunction): this {\n        return this.stopListening(\".client-\" + event, callback);\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    abstract subscribed(callback: CallableFunction): this;\n\n    /**\n     * Register a callback to be called anytime an error occurs.\n     */\n    abstract error(callback: CallableFunction): this;\n}\n","/**\n * Event name formatter\n */\nexport class EventFormatter {\n    /**\n     * Create a new class instance.\n     */\n    constructor(private namespace: string | boolean | undefined) {\n        //\n    }\n\n    /**\n     * Format the given event name.\n     */\n    format(event: string): string {\n        if ([\".\", \"\\\\\"].includes(event.charAt(0))) {\n            return event.substring(1);\n        } else if (this.namespace) {\n            event = this.namespace + \".\" + event;\n        }\n\n        return event.replace(/\\./g, \"\\\\\");\n    }\n\n    /**\n     * Set the event namespace.\n     */\n    setNamespace(value: string | boolean): void {\n        this.namespace = value;\n    }\n}\n","function isConstructor(obj: unknown): obj is new (...args: any[]) => any {\n    try {\n        new (obj as new (...args: any[]) => any)();\n    } catch (err) {\n        if (\n            err instanceof Error &&\n            err.message.includes(\"is not a constructor\")\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport { isConstructor };\nexport * from \"./event-formatter\";\n","import { EventFormatter } from \"../util\";\nimport { Channel } from \"./channel\";\nimport type Pusher from \"pusher-js\";\nimport type { Channel as BasePusherChannel } from \"pusher-js\";\nimport type { EchoOptionsWithDefaults } from \"../connector\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher channel.\n */\nexport class PusherChannel<\n    TBroadcastDriver extends BroadcastDriver,\n> extends Channel {\n    /**\n     * The Pusher client instance.\n     */\n    pusher: Pusher;\n\n    /**\n     * The name of the channel.\n     */\n    name: string;\n\n    /**\n     * The event formatter.\n     */\n    eventFormatter: EventFormatter;\n\n    /**\n     * The subscription of the channel.\n     */\n    subscription: BasePusherChannel;\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(\n        pusher: Pusher,\n        name: string,\n        options: EchoOptionsWithDefaults<TBroadcastDriver>,\n    ) {\n        super();\n\n        this.name = name;\n        this.pusher = pusher;\n        this.options = options;\n        this.eventFormatter = new EventFormatter(this.options.namespace);\n\n        this.subscribe();\n    }\n\n    /**\n     * Subscribe to a Pusher channel.\n     */\n    subscribe(): void {\n        this.subscription = this.pusher.subscribe(this.name);\n    }\n\n    /**\n     * Unsubscribe from a Pusher channel.\n     */\n    unsubscribe(): void {\n        this.pusher.unsubscribe(this.name);\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    listen(event: string, callback: CallableFunction): this {\n        this.on(this.eventFormatter.format(event), callback);\n\n        return this;\n    }\n\n    /**\n     * Listen for all events on the channel instance.\n     */\n    listenToAll(callback: CallableFunction): this {\n        this.subscription.bind_global((event: string, data: unknown) => {\n            if (event.startsWith(\"pusher:\")) {\n                return;\n            }\n\n            let namespace = String(this.options.namespace ?? \"\").replace(\n                /\\./g,\n                \"\\\\\",\n            );\n\n            let formattedEvent = event.startsWith(namespace)\n                ? event.substring(namespace.length + 1)\n                : \".\" + event;\n\n            callback(formattedEvent, data);\n        });\n\n        return this;\n    }\n\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n    stopListening(event: string, callback?: CallableFunction): this {\n        if (callback) {\n            this.subscription.unbind(\n                this.eventFormatter.format(event),\n                callback,\n            );\n        } else {\n            this.subscription.unbind(this.eventFormatter.format(event));\n        }\n\n        return this;\n    }\n\n    /**\n     * Stop listening for all events on the channel instance.\n     */\n    stopListeningToAll(callback?: CallableFunction): this {\n        if (callback) {\n            this.subscription.unbind_global(callback);\n        } else {\n            this.subscription.unbind_global();\n        }\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    subscribed(callback: CallableFunction): this {\n        this.on(\"pusher:subscription_succeeded\", () => {\n            callback();\n        });\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription error occurs.\n     */\n    error(callback: CallableFunction): this {\n        this.on(\"pusher:subscription_error\", (status: Record<string, any>) => {\n            callback(status);\n        });\n\n        return this;\n    }\n\n    /**\n     * Bind a channel to an event.\n     */\n    on(event: string, callback: CallableFunction): this {\n        this.subscription.bind(event, callback);\n\n        return this;\n    }\n}\n","import { PusherChannel } from \"./pusher-channel\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher private channel.\n */\nexport class PusherPrivateChannel<\n    TBroadcastDriver extends BroadcastDriver,\n> extends PusherChannel<TBroadcastDriver> {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: Record<any, any>): this {\n        this.pusher.channels.channels[this.name].trigger(\n            `client-${eventName}`,\n            data,\n        );\n\n        return this;\n    }\n}\n","import { PusherChannel } from \"./pusher-channel\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher private channel.\n */\nexport class PusherEncryptedPrivateChannel<\n    TBroadcastDriver extends BroadcastDriver,\n> extends PusherChannel<TBroadcastDriver> {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: Record<any, any>): this {\n        this.pusher.channels.channels[this.name].trigger(\n            `client-${eventName}`,\n            data,\n        );\n\n        return this;\n    }\n}\n","import type { PresenceChannel } from \"./presence-channel\";\nimport { PusherPrivateChannel } from \"./pusher-private-channel\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher presence channel.\n */\nexport class PusherPresenceChannel<TBroadcastDriver extends BroadcastDriver>\n    extends PusherPrivateChannel<TBroadcastDriver>\n    implements PresenceChannel\n{\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    here(callback: CallableFunction): this {\n        this.on(\"pusher:subscription_succeeded\", (data: Record<any, any>) => {\n            callback(Object.keys(data.members).map((k) => data.members[k]));\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen for someone joining the channel.\n     */\n    joining(callback: CallableFunction): this {\n        this.on(\"pusher:member_added\", (member: Record<any, any>) => {\n            callback(member.info);\n        });\n\n        return this;\n    }\n\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: Record<any, any>): this {\n        this.pusher.channels.channels[this.name].trigger(\n            `client-${eventName}`,\n            data,\n        );\n\n        return this;\n    }\n\n    /**\n     * Listen for someone leaving the channel.\n     */\n    leaving(callback: CallableFunction): this {\n        this.on(\"pusher:member_removed\", (member: Record<any, any>) => {\n            callback(member.info);\n        });\n\n        return this;\n    }\n}\n","import { EventFormatter } from \"../util\";\nimport { Channel } from \"./channel\";\nimport type { Socket } from \"socket.io-client\";\nimport type { EchoOptionsWithDefaults } from \"../connector\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Socket.io channel.\n */\nexport class SocketIoChannel extends Channel {\n    /**\n     * The Socket.io client instance.\n     */\n    socket: Socket;\n\n    /**\n     * The name of the channel.\n     */\n    name: string;\n\n    /**\n     * The event formatter.\n     */\n    eventFormatter: EventFormatter;\n\n    /**\n     * The event callbacks applied to the socket.\n     */\n    events: Record<string, any> = {};\n\n    /**\n     * User supplied callbacks for events on this channel.\n     */\n    private listeners: Record<string, CallableFunction[]> = {};\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(\n        socket: Socket,\n        name: string,\n        options: EchoOptionsWithDefaults<BroadcastDriver>,\n    ) {\n        super();\n\n        this.name = name;\n        this.socket = socket;\n        this.options = options;\n        this.eventFormatter = new EventFormatter(this.options.namespace);\n\n        this.subscribe();\n    }\n\n    /**\n     * Subscribe to a Socket.io channel.\n     */\n    subscribe(): void {\n        this.socket.emit(\"subscribe\", {\n            channel: this.name,\n            auth: this.options.auth || {},\n        });\n    }\n\n    /**\n     * Unsubscribe from channel and ubind event callbacks.\n     */\n    unsubscribe(): void {\n        this.unbind();\n\n        this.socket.emit(\"unsubscribe\", {\n            channel: this.name,\n            auth: this.options.auth || {},\n        });\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    listen(event: string, callback: CallableFunction): this {\n        this.on(this.eventFormatter.format(event), callback);\n\n        return this;\n    }\n\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n    stopListening(event: string, callback?: CallableFunction): this {\n        this.unbindEvent(this.eventFormatter.format(event), callback);\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    subscribed(callback: CallableFunction): this {\n        this.on(\"connect\", (socket: Socket) => {\n            callback(socket);\n        });\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime an error occurs.\n     */\n    error(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Bind the channel's socket to an event and store the callback.\n     */\n    on(event: string, callback: CallableFunction): this {\n        this.listeners[event] = this.listeners[event] || [];\n\n        if (!this.events[event]) {\n            this.events[event] = (channel: string, data: unknown) => {\n                if (this.name === channel && this.listeners[event]) {\n                    this.listeners[event].forEach((cb) => cb(data));\n                }\n            };\n\n            this.socket.on(event, this.events[event]);\n        }\n\n        this.listeners[event].push(callback);\n\n        return this;\n    }\n\n    /**\n     * Unbind the channel's socket from all stored event callbacks.\n     */\n    unbind(): void {\n        Object.keys(this.events).forEach((event) => {\n            this.unbindEvent(event);\n        });\n    }\n\n    /**\n     * Unbind the listeners for the given event.\n     */\n    protected unbindEvent(event: string, callback?: CallableFunction): void {\n        this.listeners[event] = this.listeners[event] || [];\n\n        if (callback) {\n            this.listeners[event] = this.listeners[event].filter(\n                (cb) => cb !== callback,\n            );\n        }\n\n        if (!callback || this.listeners[event].length === 0) {\n            if (this.events[event]) {\n                this.socket.removeListener(event, this.events[event]);\n\n                delete this.events[event];\n            }\n\n            delete this.listeners[event];\n        }\n    }\n}\n","import { SocketIoChannel } from \"./socketio-channel\";\n\n/**\n * This class represents a Socket.io private channel.\n */\nexport class SocketIoPrivateChannel extends SocketIoChannel {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: unknown): this {\n        this.socket.emit(\"client event\", {\n            channel: this.name,\n            event: `client-${eventName}`,\n            data: data,\n        });\n\n        return this;\n    }\n}\n","import type { PresenceChannel } from \"./presence-channel\";\nimport { SocketIoPrivateChannel } from \"./socketio-private-channel\";\n\n/**\n * This class represents a Socket.io presence channel.\n */\nexport class SocketIoPresenceChannel\n    extends SocketIoPrivateChannel\n    implements PresenceChannel\n{\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    here(callback: CallableFunction): this {\n        this.on(\"presence:subscribed\", (members: Record<string, any>[]) => {\n            callback(members.map((m) => m.user_info));\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen for someone joining the channel.\n     */\n    joining(callback: CallableFunction): this {\n        this.on(\"presence:joining\", (member: Record<string, any>) =>\n            callback(member.user_info),\n        );\n\n        return this;\n    }\n\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: unknown): this {\n        this.socket.emit(\"client event\", {\n            channel: this.name,\n            event: `client-${eventName}`,\n            data: data,\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen for someone leaving the channel.\n     */\n    leaving(callback: CallableFunction): this {\n        this.on(\"presence:leaving\", (member: Record<string, any>) =>\n            callback(member.user_info),\n        );\n\n        return this;\n    }\n}\n","import { Channel } from \"./channel\";\n\n/**\n * This class represents a null channel.\n */\nexport class NullChannel extends Channel {\n    /**\n     * Subscribe to a channel.\n     */\n    subscribe(): void {\n        //\n    }\n\n    /**\n     * Unsubscribe from a channel.\n     */\n    unsubscribe(): void {\n        //\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    listen(_event: string, _callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Listen for all events on the channel instance.\n     */\n    listenToAll(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n    stopListening(_event: string, _callback?: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    subscribed(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime an error occurs.\n     */\n    error(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Bind a channel to an event.\n     */\n    on(_event: string, _callback: CallableFunction): this {\n        return this;\n    }\n}\n","import { NullChannel } from \"./null-channel\";\n\n/**\n * This class represents a null private channel.\n */\nexport class NullPrivateChannel extends NullChannel {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(_eventName: string, _data: Record<any, any>): this {\n        return this;\n    }\n}\n","import { NullChannel } from \"./null-channel\";\n\n/**\n * This class represents a null private channel.\n */\nexport class NullEncryptedPrivateChannel extends NullChannel {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(_eventName: string, _data: Record<any, any>): this {\n        return this;\n    }\n}\n","import { NullPrivateChannel } from \"./null-private-channel\";\nimport type { PresenceChannel } from \"./presence-channel\";\n\n/**\n * This class represents a null presence channel.\n */\nexport class NullPresenceChannel\n    extends NullPrivateChannel\n    implements PresenceChannel\n{\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    here(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Listen for someone joining the channel.\n     */\n    joining(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(_eventName: string, _data: Record<any, any>): this {\n        return this;\n    }\n\n    /**\n     * Listen for someone leaving the channel.\n     */\n    leaving(_callback: CallableFunction): this {\n        return this;\n    }\n}\n","/// <reference types=\"window\" />\n\nimport type { Channel, PresenceChannel } from \"../channel\";\nimport type { BroadcastDriver, EchoOptions } from \"../echo\";\n\nexport type EchoOptionsWithDefaults<TBroadcaster extends BroadcastDriver> = {\n    broadcaster: TBroadcaster;\n    auth: {\n        headers: Record<string, string>;\n    };\n    authEndpoint: string;\n    userAuthentication: {\n        endpoint: string;\n        headers: Record<string, string>;\n    };\n    csrfToken: string | null;\n    bearerToken: string | null;\n    host: string | null;\n    key: string | null;\n    namespace: string | false;\n\n    [key: string]: any;\n};\n\nexport abstract class Connector<\n    TBroadcastDriver extends BroadcastDriver,\n    TPublic extends Channel,\n    TPrivate extends Channel,\n    TPresence extends PresenceChannel,\n> {\n    /**\n     * Default connector options.\n     */\n    public static readonly _defaultOptions = {\n        auth: {\n            headers: {},\n        },\n        authEndpoint: \"/broadcasting/auth\",\n        userAuthentication: {\n            endpoint: \"/broadcasting/user-auth\",\n            headers: {},\n        },\n        csrfToken: null,\n        bearerToken: null,\n        host: null,\n        key: null,\n        namespace: \"App.Events\",\n    } as const;\n\n    /**\n     * Connector options.\n     */\n    options: EchoOptionsWithDefaults<TBroadcastDriver>;\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(options: EchoOptions<TBroadcastDriver>) {\n        this.setOptions(options);\n        this.connect();\n    }\n\n    /**\n     * Merge the custom options with the defaults.\n     */\n    protected setOptions(options: EchoOptions<TBroadcastDriver>): void {\n        this.options = {\n            ...Connector._defaultOptions,\n            ...options,\n            broadcaster: options.broadcaster as TBroadcastDriver,\n        };\n\n        let token = this.csrfToken();\n\n        if (token) {\n            this.options.auth.headers[\"X-CSRF-TOKEN\"] = token;\n            this.options.userAuthentication.headers[\"X-CSRF-TOKEN\"] = token;\n        }\n\n        token = this.options.bearerToken;\n\n        if (token) {\n            this.options.auth.headers[\"Authorization\"] = \"Bearer \" + token;\n            this.options.userAuthentication.headers[\"Authorization\"] =\n                \"Bearer \" + token;\n        }\n    }\n\n    /**\n     * Extract the CSRF token from the page.\n     */\n    protected csrfToken(): null | string {\n        if (typeof window !== \"undefined\" && window.Laravel?.csrfToken) {\n            return window.Laravel.csrfToken;\n        }\n\n        if (this.options.csrfToken) {\n            return this.options.csrfToken;\n        }\n\n        if (\n            typeof document !== \"undefined\" &&\n            typeof document.querySelector === \"function\"\n        ) {\n            return (\n                document\n                    .querySelector('meta[name=\"csrf-token\"]')\n                    ?.getAttribute(\"content\") ?? null\n            );\n        }\n\n        return null;\n    }\n\n    /**\n     * Create a fresh connection.\n     */\n    abstract connect(): void;\n\n    /**\n     * Get a channel instance by name.\n     */\n    abstract channel(channel: string): TPublic;\n\n    /**\n     * Get a private channel instance by name.\n     */\n    abstract privateChannel(channel: string): TPrivate;\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    abstract presenceChannel(channel: string): TPresence;\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    abstract leave(channel: string): void;\n\n    /**\n     * Leave the given channel.\n     */\n    abstract leaveChannel(channel: string): void;\n\n    /**\n     * Get the socket_id of the connection.\n     */\n    abstract socketId(): string | undefined;\n\n    /**\n     * Disconnect from the Echo server.\n     */\n    abstract disconnect(): void;\n}\n","import type Pusher from \"pusher-js\";\nimport type { Options as PusherJsOptions } from \"pusher-js\";\nimport {\n    PusherChannel,\n    PusherEncryptedPrivateChannel,\n    PusherPresenceChannel,\n    PusherPrivateChannel,\n} from \"../channel\";\nimport type { BroadcastDriver } from \"../echo\";\nimport { Connector, type EchoOptionsWithDefaults } from \"./connector\";\n\ntype AnyPusherChannel =\n    | PusherChannel<BroadcastDriver>\n    | PusherPrivateChannel<BroadcastDriver>\n    | PusherEncryptedPrivateChannel<BroadcastDriver>\n    | PusherPresenceChannel<BroadcastDriver>;\n\nexport type PusherOptions<TBroadcastDriver extends BroadcastDriver> =\n    EchoOptionsWithDefaults<TBroadcastDriver> & {\n        key: string;\n        Pusher?: typeof Pusher;\n    } & PusherJsOptions;\n\n/**\n * This class creates a connector to Pusher.\n */\nexport class PusherConnector<\n    TBroadcastDriver extends BroadcastDriver,\n> extends Connector<\n    TBroadcastDriver,\n    PusherChannel<TBroadcastDriver>,\n    PusherPrivateChannel<TBroadcastDriver>,\n    PusherPresenceChannel<TBroadcastDriver>\n> {\n    /**\n     * The Pusher instance.\n     */\n    pusher: Pusher;\n\n    /**\n     * All of the subscribed channel names.\n     */\n    channels: Record<string, AnyPusherChannel> = {};\n\n    declare options: PusherOptions<TBroadcastDriver>;\n\n    /**\n     * Create a fresh Pusher connection.\n     */\n    connect(): void {\n        if (typeof this.options.client !== \"undefined\") {\n            this.pusher = this.options.client as Pusher;\n        } else if (this.options.Pusher) {\n            this.pusher = new this.options.Pusher(\n                this.options.key,\n                this.options,\n            );\n        } else if (\n            typeof window !== \"undefined\" &&\n            typeof window.Pusher !== \"undefined\"\n        ) {\n            this.pusher = new window.Pusher(this.options.key, this.options);\n        } else {\n            throw new Error(\n                \"Pusher client not found. Should be globally available or passed via options.client\",\n            );\n        }\n    }\n\n    /**\n     * Sign in the user via Pusher user authentication (https://pusher.com/docs/channels/using_channels/user-authentication/).\n     */\n    signin(): void {\n        this.pusher.signin();\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        name: string,\n        event: string,\n        callback: CallableFunction,\n    ): AnyPusherChannel {\n        return this.channel(name).listen(event, callback);\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(name: string): AnyPusherChannel {\n        if (!this.channels[name]) {\n            this.channels[name] = new PusherChannel(\n                this.pusher,\n                name,\n                this.options,\n            );\n        }\n\n        return this.channels[name];\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    privateChannel(name: string): PusherPrivateChannel<TBroadcastDriver> {\n        if (!this.channels[\"private-\" + name]) {\n            this.channels[\"private-\" + name] = new PusherPrivateChannel(\n                this.pusher,\n                \"private-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\n            \"private-\" + name\n        ] as PusherPrivateChannel<TBroadcastDriver>;\n    }\n\n    /**\n     * Get a private encrypted channel instance by name.\n     */\n    encryptedPrivateChannel(\n        name: string,\n    ): PusherEncryptedPrivateChannel<TBroadcastDriver> {\n        if (!this.channels[\"private-encrypted-\" + name]) {\n            this.channels[\"private-encrypted-\" + name] =\n                new PusherEncryptedPrivateChannel(\n                    this.pusher,\n                    \"private-encrypted-\" + name,\n                    this.options,\n                );\n        }\n\n        return this.channels[\n            \"private-encrypted-\" + name\n        ] as PusherEncryptedPrivateChannel<TBroadcastDriver>;\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    presenceChannel(name: string): PusherPresenceChannel<TBroadcastDriver> {\n        if (!this.channels[\"presence-\" + name]) {\n            this.channels[\"presence-\" + name] = new PusherPresenceChannel(\n                this.pusher,\n                \"presence-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\n            \"presence-\" + name\n        ] as PusherPresenceChannel<TBroadcastDriver>;\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(name: string): void {\n        let channels = [\n            name,\n            \"private-\" + name,\n            \"private-encrypted-\" + name,\n            \"presence-\" + name,\n        ];\n\n        channels.forEach((name: string) => {\n            this.leaveChannel(name);\n        });\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(name: string): void {\n        if (this.channels[name]) {\n            this.channels[name].unsubscribe();\n\n            delete this.channels[name];\n        }\n    }\n\n    /**\n     * Get the socket ID for the connection.\n     */\n    socketId(): string {\n        return this.pusher.connection.socket_id;\n    }\n\n    /**\n     * Disconnect Pusher connection.\n     */\n    disconnect(): void {\n        this.pusher.disconnect();\n    }\n}\n","import { Connector } from \"./connector\";\nimport {\n    SocketIoChannel,\n    SocketIoPrivateChannel,\n    SocketIoPresenceChannel,\n} from \"../channel\";\nimport type {\n    io,\n    ManagerOptions,\n    Socket,\n    SocketOptions,\n} from \"socket.io-client\";\n\ntype AnySocketIoChannel =\n    | SocketIoChannel\n    | SocketIoPrivateChannel\n    | SocketIoPresenceChannel;\n\n/**\n * This class creates a connector to a Socket.io server.\n */\nexport class SocketIoConnector extends Connector<\n    \"socket.io\",\n    SocketIoChannel,\n    SocketIoPrivateChannel,\n    SocketIoPresenceChannel\n> {\n    /**\n     * The Socket.io connection instance.\n     */\n    socket: Socket;\n\n    /**\n     * All of the subscribed channel names.\n     */\n    channels: { [name: string]: SocketIoChannel } = {};\n\n    /**\n     * Create a fresh Socket.io connection.\n     */\n    connect(): void {\n        let io = this.getSocketIO();\n\n        this.socket = io(\n            this.options.host ?? undefined,\n            this.options as Partial<ManagerOptions & SocketOptions>,\n        );\n\n        this.socket.io.on(\"reconnect\", () => {\n            Object.values(this.channels).forEach((channel) => {\n                channel.subscribe();\n            });\n        });\n    }\n\n    /**\n     * Get socket.io module from global scope or options.\n     */\n    getSocketIO(): typeof io {\n        if (typeof this.options.client !== \"undefined\") {\n            return this.options.client as typeof io;\n        }\n\n        if (typeof window !== \"undefined\" && typeof window.io !== \"undefined\") {\n            return window.io;\n        }\n\n        throw new Error(\n            \"Socket.io client not found. Should be globally available or passed via options.client\",\n        );\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        name: string,\n        event: string,\n        callback: CallableFunction,\n    ): AnySocketIoChannel {\n        return this.channel(name).listen(event, callback);\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(name: string): AnySocketIoChannel {\n        if (!this.channels[name]) {\n            this.channels[name] = new SocketIoChannel(\n                this.socket,\n                name,\n                this.options,\n            );\n        }\n\n        return this.channels[name];\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    privateChannel(name: string): SocketIoPrivateChannel {\n        if (!this.channels[\"private-\" + name]) {\n            this.channels[\"private-\" + name] = new SocketIoPrivateChannel(\n                this.socket,\n                \"private-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\"private-\" + name] as SocketIoPrivateChannel;\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    presenceChannel(name: string): SocketIoPresenceChannel {\n        if (!this.channels[\"presence-\" + name]) {\n            this.channels[\"presence-\" + name] = new SocketIoPresenceChannel(\n                this.socket,\n                \"presence-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\"presence-\" + name] as SocketIoPresenceChannel;\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(name: string): void {\n        let channels = [name, \"private-\" + name, \"presence-\" + name];\n\n        channels.forEach((name) => {\n            this.leaveChannel(name);\n        });\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(name: string): void {\n        if (this.channels[name]) {\n            this.channels[name].unsubscribe();\n\n            delete this.channels[name];\n        }\n    }\n\n    /**\n     * Get the socket ID for the connection.\n     */\n    socketId(): string | undefined {\n        return this.socket.id;\n    }\n\n    /**\n     * Disconnect Socketio connection.\n     */\n    disconnect(): void {\n        this.socket.disconnect();\n    }\n}\n","import { Connector } from \"./connector\";\nimport {\n    NullChannel,\n    NullPrivateChannel,\n    NullPresenceChannel,\n    NullEncryptedPrivateChannel,\n} from \"../channel\";\n\n/**\n * This class creates a null connector.\n */\nexport class NullConnector extends Connector<\n    \"null\",\n    NullChannel,\n    NullPrivateChannel,\n    NullPresenceChannel\n> {\n    /**\n     * All of the subscribed channel names.\n     */\n    channels: any = {};\n\n    /**\n     * Create a fresh connection.\n     */\n    connect(): void {\n        //\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        _name: string,\n        _event: string,\n        _callback: CallableFunction,\n    ): NullChannel {\n        return new NullChannel();\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(_name: string): NullChannel {\n        return new NullChannel();\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    privateChannel(_name: string): NullPrivateChannel {\n        return new NullPrivateChannel();\n    }\n\n    /**\n     * Get a private encrypted channel instance by name.\n     */\n    encryptedPrivateChannel(_name: string): NullEncryptedPrivateChannel {\n        return new NullEncryptedPrivateChannel();\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    presenceChannel(_name: string): NullPresenceChannel {\n        return new NullPresenceChannel();\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(_name: string): void {\n        //\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(_name: string): void {\n        //\n    }\n\n    /**\n     * Get the socket ID for the connection.\n     */\n    socketId(): string {\n        return \"fake-socket-id\";\n    }\n\n    /**\n     * Disconnect the connection.\n     */\n    disconnect(): void {\n        //\n    }\n}\n","import type { InternalAxiosRequestConfig } from \"axios\";\nimport {\n    Channel,\n    NullChannel,\n    NullEncryptedPrivateChannel,\n    NullPresenceChannel,\n    NullPrivateChannel,\n    PusherChannel,\n    PusherEncryptedPrivateChannel,\n    PusherPresenceChannel,\n    PusherPrivateChannel,\n    SocketIoChannel,\n    SocketIoPresenceChannel,\n    SocketIoPrivateChannel,\n    type PresenceChannel,\n} from \"./channel\";\nimport {\n    Connector,\n    NullConnector,\n    PusherConnector,\n    SocketIoConnector,\n    type PusherOptions,\n} from \"./connector\";\nimport { isConstructor } from \"./util\";\n\n/**\n * This class is the primary API for interacting with broadcasting.\n */\nexport default class Echo<T extends keyof Broadcaster> {\n    /**\n     * The broadcasting connector.\n     */\n    connector: Broadcaster[Exclude<T, \"function\">][\"connector\"];\n\n    /**\n     * The Echo options.\n     */\n    options: EchoOptions<T>;\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(options: EchoOptions<T>) {\n        this.options = options;\n        this.connect();\n\n        if (!this.options.withoutInterceptors) {\n            this.registerInterceptors();\n        }\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(channel: string): Broadcaster[T][\"public\"] {\n        return this.connector.channel(channel);\n    }\n\n    /**\n     * Create a new connection.\n     */\n    connect(): void {\n        if (this.options.broadcaster === \"reverb\") {\n            this.connector = new PusherConnector<\"reverb\">({\n                ...this.options,\n                cluster: \"\",\n            });\n        } else if (this.options.broadcaster === \"pusher\") {\n            this.connector = new PusherConnector<\"pusher\">(this.options);\n        } else if (this.options.broadcaster === \"ably\") {\n            this.connector = new PusherConnector<\"pusher\">({\n                ...this.options,\n                cluster: \"\",\n                broadcaster: \"pusher\",\n            });\n        } else if (this.options.broadcaster === \"socket.io\") {\n            this.connector = new SocketIoConnector(this.options);\n        } else if (this.options.broadcaster === \"null\") {\n            this.connector = new NullConnector(this.options);\n        } else if (\n            typeof this.options.broadcaster === \"function\" &&\n            isConstructor(this.options.broadcaster)\n        ) {\n            this.connector = new this.options.broadcaster(this.options);\n        } else {\n            throw new Error(\n                `Broadcaster ${typeof this.options.broadcaster} ${String(this.options.broadcaster)} is not supported.`,\n            );\n        }\n    }\n\n    /**\n     * Disconnect from the Echo server.\n     */\n    disconnect(): void {\n        this.connector.disconnect();\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    join(channel: string): Broadcaster[T][\"presence\"] {\n        return this.connector.presenceChannel(channel);\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(channel: string): void {\n        this.connector.leave(channel);\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(channel: string): void {\n        this.connector.leaveChannel(channel);\n    }\n\n    /**\n     * Leave all channels.\n     */\n    leaveAllChannels(): void {\n        for (const channel in this.connector.channels) {\n            this.leaveChannel(channel);\n        }\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        channel: string,\n        event: string,\n        callback: CallableFunction,\n    ): Broadcaster[T][\"public\"] {\n        return this.connector.listen(channel, event, callback);\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    private(channel: string): Broadcaster[T][\"private\"] {\n        return this.connector.privateChannel(channel);\n    }\n\n    /**\n     * Get a private encrypted channel instance by name.\n     */\n    encryptedPrivate(channel: string): Broadcaster[T][\"encrypted\"] {\n        if (this.connectorSupportsEncryptedPrivateChannels(this.connector)) {\n            return this.connector.encryptedPrivateChannel(channel);\n        }\n\n        throw new Error(\n            `Broadcaster ${typeof this.options.broadcaster} ${String(\n                this.options.broadcaster,\n            )} does not support encrypted private channels.`,\n        );\n    }\n\n    private connectorSupportsEncryptedPrivateChannels(\n        connector: unknown,\n    ): connector is PusherConnector<any> | NullConnector {\n        return (\n            connector instanceof PusherConnector ||\n            connector instanceof NullConnector\n        );\n    }\n\n    /**\n     * Get the Socket ID for the connection.\n     */\n    socketId(): string | undefined {\n        return this.connector.socketId();\n    }\n\n    /**\n     * Register 3rd party request interceptiors. These are used to automatically\n     * send a connections socket id to a Laravel app with a X-Socket-Id header.\n     */\n    registerInterceptors(): void {\n        // TODO: This package is deprecated and we should remove it in a future version.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (typeof Vue !== \"undefined\" && Vue?.http) {\n            this.registerVueRequestInterceptor();\n        }\n\n        if (typeof axios === \"function\") {\n            this.registerAxiosRequestInterceptor();\n        }\n\n        if (typeof jQuery === \"function\") {\n            this.registerjQueryAjaxSetup();\n        }\n\n        if (typeof Turbo === \"object\") {\n            this.registerTurboRequestInterceptor();\n        }\n    }\n\n    /**\n     * Register a Vue HTTP interceptor to add the X-Socket-ID header.\n     */\n    registerVueRequestInterceptor(): void {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        Vue.http.interceptors.push(\n            (request: Record<any, any>, next: CallableFunction) => {\n                if (this.socketId()) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                    request.headers.set(\"X-Socket-ID\", this.socketId());\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                next();\n            },\n        );\n    }\n\n    /**\n     * Register an Axios HTTP interceptor to add the X-Socket-ID header.\n     */\n    registerAxiosRequestInterceptor(): void {\n        axios!.interceptors.request.use(\n            (config: InternalAxiosRequestConfig<any>) => {\n                if (this.socketId()) {\n                    config.headers[\"X-Socket-Id\"] = this.socketId();\n                }\n\n                return config;\n            },\n        );\n    }\n\n    /**\n     * Register jQuery AjaxPrefilter to add the X-Socket-ID header.\n     */\n    registerjQueryAjaxSetup(): void {\n        if (typeof jQuery.ajax != \"undefined\") {\n            jQuery.ajaxPrefilter(\n                (\n                    _options: any,\n                    _originalOptions: any,\n                    xhr: Record<any, any>,\n                ) => {\n                    if (this.socketId()) {\n                        xhr.setRequestHeader(\"X-Socket-Id\", this.socketId());\n                    }\n                },\n            );\n        }\n    }\n\n    /**\n     * Register the Turbo Request interceptor to add the X-Socket-ID header.\n     */\n    registerTurboRequestInterceptor(): void {\n        document.addEventListener(\n            \"turbo:before-fetch-request\",\n            (event: Record<any, any>) => {\n                event.detail.fetchOptions.headers[\"X-Socket-Id\"] =\n                    this.socketId();\n            },\n        );\n    }\n}\n\n/**\n * Export channel classes for TypeScript.\n */\nexport { Channel, Connector, type PresenceChannel };\n\nexport { EventFormatter } from \"./util\";\n\ntype CustomOmit<T, K extends PropertyKey> = {\n    [P in keyof T as Exclude<P, K>]: T[P];\n};\n\n/**\n * Specifies the broadcaster\n */\nexport type Broadcaster = {\n    reverb: {\n        connector: PusherConnector<\"reverb\">;\n        public: PusherChannel<\"reverb\">;\n        private: PusherPrivateChannel<\"reverb\">;\n        encrypted: PusherEncryptedPrivateChannel<\"reverb\">;\n        presence: PusherPresenceChannel<\"reverb\">;\n        options: GenericOptions<\"reverb\"> &\n            Partial<CustomOmit<PusherOptions<\"reverb\">, \"cluster\">>;\n    };\n    pusher: {\n        connector: PusherConnector<\"pusher\">;\n        public: PusherChannel<\"pusher\">;\n        private: PusherPrivateChannel<\"pusher\">;\n        encrypted: PusherEncryptedPrivateChannel<\"pusher\">;\n        presence: PusherPresenceChannel<\"pusher\">;\n        options: GenericOptions<\"pusher\"> & Partial<PusherOptions<\"pusher\">>;\n    };\n    ably: {\n        connector: PusherConnector<\"pusher\">;\n        public: PusherChannel<\"pusher\">;\n        private: PusherPrivateChannel<\"pusher\">;\n        encrypted: PusherEncryptedPrivateChannel<\"pusher\">;\n        presence: PusherPresenceChannel<\"pusher\">;\n        options: GenericOptions<\"ably\"> & Partial<PusherOptions<\"ably\">>;\n    };\n    \"socket.io\": {\n        connector: SocketIoConnector;\n        public: SocketIoChannel;\n        private: SocketIoPrivateChannel;\n        encrypted: never;\n        presence: SocketIoPresenceChannel;\n        options: GenericOptions<\"socket.io\">;\n    };\n    null: {\n        connector: NullConnector;\n        public: NullChannel;\n        private: NullPrivateChannel;\n        encrypted: NullEncryptedPrivateChannel;\n        presence: NullPresenceChannel;\n        options: GenericOptions<\"null\">;\n    };\n    function: {\n        connector: any;\n        public: any;\n        private: any;\n        encrypted: any;\n        presence: any;\n        options: GenericOptions<\"function\">;\n    };\n};\n\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nexport type BroadcastDriver = Exclude<keyof Broadcaster, \"function\">;\n\ntype GenericOptions<TBroadcaster extends keyof Broadcaster> = {\n    /**\n     * The broadcast connector.\n     */\n    broadcaster: TBroadcaster extends \"function\"\n        ? Constructor<InstanceType<Broadcaster[TBroadcaster][\"connector\"]>>\n        : TBroadcaster;\n\n    auth?: {\n        headers: Record<string, string>;\n    };\n    authEndpoint?: string;\n    userAuthentication?: {\n        endpoint: string;\n        headers: Record<string, string>;\n    };\n    csrfToken?: string | null;\n    bearerToken?: string | null;\n    host?: string | null;\n    key?: string | null;\n    namespace?: string | false;\n    withoutInterceptors?: boolean;\n\n    [key: string]: any;\n};\n\nexport type EchoOptions<TBroadcaster extends keyof Broadcaster> =\n    Broadcaster[TBroadcaster][\"options\"];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}