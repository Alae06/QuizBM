{"ast":null,"code":"class l {\n  /**\n   * Listen for a whisper event on the channel instance.\n   */\n  listenForWhisper(e, t) {\n    return this.listen(\".client-\" + e, t);\n  }\n  /**\n   * Listen for an event on the channel instance.\n   */\n  notification(e) {\n    return this.listen(\".Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated\", e);\n  }\n  /**\n   * Stop listening for a whisper event on the channel instance.\n   */\n  stopListeningForWhisper(e, t) {\n    return this.stopListening(\".client-\" + e, t);\n  }\n}\nclass d {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e) {\n    this.namespace = e;\n  }\n  /**\n   * Format the given event name.\n   */\n  format(e) {\n    return [\".\", \"\\\\\"].includes(e.charAt(0)) ? e.substring(1) : (this.namespace && (e = this.namespace + \".\" + e), e.replace(/\\./g, \"\\\\\"));\n  }\n  /**\n   * Set the event namespace.\n   */\n  setNamespace(e) {\n    this.namespace = e;\n  }\n}\nfunction w(n) {\n  try {\n    new n();\n  } catch (e) {\n    if (e instanceof Error && e.message.includes(\"is not a constructor\")) return !1;\n  }\n  return !0;\n}\nclass u extends l {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e, t, s) {\n    super(), this.name = t, this.pusher = e, this.options = s, this.eventFormatter = new d(this.options.namespace), this.subscribe();\n  }\n  /**\n   * Subscribe to a Pusher channel.\n   */\n  subscribe() {\n    this.subscription = this.pusher.subscribe(this.name);\n  }\n  /**\n   * Unsubscribe from a Pusher channel.\n   */\n  unsubscribe() {\n    this.pusher.unsubscribe(this.name);\n  }\n  /**\n   * Listen for an event on the channel instance.\n   */\n  listen(e, t) {\n    return this.on(this.eventFormatter.format(e), t), this;\n  }\n  /**\n   * Listen for all events on the channel instance.\n   */\n  listenToAll(e) {\n    return this.subscription.bind_global((t, s) => {\n      if (t.startsWith(\"pusher:\")) return;\n      let r = String(this.options.namespace ?? \"\").replace(/\\./g, \"\\\\\"),\n        a = t.startsWith(r) ? t.substring(r.length + 1) : \".\" + t;\n      e(a, s);\n    }), this;\n  }\n  /**\n   * Stop listening for an event on the channel instance.\n   */\n  stopListening(e, t) {\n    return t ? this.subscription.unbind(this.eventFormatter.format(e), t) : this.subscription.unbind(this.eventFormatter.format(e)), this;\n  }\n  /**\n   * Stop listening for all events on the channel instance.\n   */\n  stopListeningToAll(e) {\n    return e ? this.subscription.unbind_global(e) : this.subscription.unbind_global(), this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription succeeds.\n   */\n  subscribed(e) {\n    return this.on(\"pusher:subscription_succeeded\", () => {\n      e();\n    }), this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription error occurs.\n   */\n  error(e) {\n    return this.on(\"pusher:subscription_error\", t => {\n      e(t);\n    }), this;\n  }\n  /**\n   * Bind a channel to an event.\n   */\n  on(e, t) {\n    return this.subscription.bind(e, t), this;\n  }\n}\nclass f extends u {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.pusher.channels.channels[this.name].trigger(`client-${e}`, t), this;\n  }\n}\nclass g extends u {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.pusher.channels.channels[this.name].trigger(`client-${e}`, t), this;\n  }\n}\nclass y extends f {\n  /**\n   * Register a callback to be called anytime the member list changes.\n   */\n  here(e) {\n    return this.on(\"pusher:subscription_succeeded\", t => {\n      e(Object.keys(t.members).map(s => t.members[s]));\n    }), this;\n  }\n  /**\n   * Listen for someone joining the channel.\n   */\n  joining(e) {\n    return this.on(\"pusher:member_added\", t => {\n      e(t.info);\n    }), this;\n  }\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.pusher.channels.channels[this.name].trigger(`client-${e}`, t), this;\n  }\n  /**\n   * Listen for someone leaving the channel.\n   */\n  leaving(e) {\n    return this.on(\"pusher:member_removed\", t => {\n      e(t.info);\n    }), this;\n  }\n}\nclass b extends l {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e, t, s) {\n    super(), this.events = {}, this.listeners = {}, this.name = t, this.socket = e, this.options = s, this.eventFormatter = new d(this.options.namespace), this.subscribe();\n  }\n  /**\n   * Subscribe to a Socket.io channel.\n   */\n  subscribe() {\n    this.socket.emit(\"subscribe\", {\n      channel: this.name,\n      auth: this.options.auth || {}\n    });\n  }\n  /**\n   * Unsubscribe from channel and ubind event callbacks.\n   */\n  unsubscribe() {\n    this.unbind(), this.socket.emit(\"unsubscribe\", {\n      channel: this.name,\n      auth: this.options.auth || {}\n    });\n  }\n  /**\n   * Listen for an event on the channel instance.\n   */\n  listen(e, t) {\n    return this.on(this.eventFormatter.format(e), t), this;\n  }\n  /**\n   * Stop listening for an event on the channel instance.\n   */\n  stopListening(e, t) {\n    return this.unbindEvent(this.eventFormatter.format(e), t), this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription succeeds.\n   */\n  subscribed(e) {\n    return this.on(\"connect\", t => {\n      e(t);\n    }), this;\n  }\n  /**\n   * Register a callback to be called anytime an error occurs.\n   */\n  error(e) {\n    return this;\n  }\n  /**\n   * Bind the channel's socket to an event and store the callback.\n   */\n  on(e, t) {\n    return this.listeners[e] = this.listeners[e] || [], this.events[e] || (this.events[e] = (s, r) => {\n      this.name === s && this.listeners[e] && this.listeners[e].forEach(a => a(r));\n    }, this.socket.on(e, this.events[e])), this.listeners[e].push(t), this;\n  }\n  /**\n   * Unbind the channel's socket from all stored event callbacks.\n   */\n  unbind() {\n    Object.keys(this.events).forEach(e => {\n      this.unbindEvent(e);\n    });\n  }\n  /**\n   * Unbind the listeners for the given event.\n   */\n  unbindEvent(e, t) {\n    this.listeners[e] = this.listeners[e] || [], t && (this.listeners[e] = this.listeners[e].filter(s => s !== t)), (!t || this.listeners[e].length === 0) && (this.events[e] && (this.socket.removeListener(e, this.events[e]), delete this.events[e]), delete this.listeners[e]);\n  }\n}\nclass v extends b {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.socket.emit(\"client event\", {\n      channel: this.name,\n      event: `client-${e}`,\n      data: t\n    }), this;\n  }\n}\nclass m extends v {\n  /**\n   * Register a callback to be called anytime the member list changes.\n   */\n  here(e) {\n    return this.on(\"presence:subscribed\", t => {\n      e(t.map(s => s.user_info));\n    }), this;\n  }\n  /**\n   * Listen for someone joining the channel.\n   */\n  joining(e) {\n    return this.on(\"presence:joining\", t => e(t.user_info)), this;\n  }\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this.socket.emit(\"client event\", {\n      channel: this.name,\n      event: `client-${e}`,\n      data: t\n    }), this;\n  }\n  /**\n   * Listen for someone leaving the channel.\n   */\n  leaving(e) {\n    return this.on(\"presence:leaving\", t => e(t.user_info)), this;\n  }\n}\nclass h extends l {\n  /**\n   * Subscribe to a channel.\n   */\n  subscribe() {}\n  /**\n   * Unsubscribe from a channel.\n   */\n  unsubscribe() {}\n  /**\n   * Listen for an event on the channel instance.\n   */\n  listen(e, t) {\n    return this;\n  }\n  /**\n   * Listen for all events on the channel instance.\n   */\n  listenToAll(e) {\n    return this;\n  }\n  /**\n   * Stop listening for an event on the channel instance.\n   */\n  stopListening(e, t) {\n    return this;\n  }\n  /**\n   * Register a callback to be called anytime a subscription succeeds.\n   */\n  subscribed(e) {\n    return this;\n  }\n  /**\n   * Register a callback to be called anytime an error occurs.\n   */\n  error(e) {\n    return this;\n  }\n  /**\n   * Bind a channel to an event.\n   */\n  on(e, t) {\n    return this;\n  }\n}\nclass k extends h {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this;\n  }\n}\nclass _ extends h {\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this;\n  }\n}\nclass C extends k {\n  /**\n   * Register a callback to be called anytime the member list changes.\n   */\n  here(e) {\n    return this;\n  }\n  /**\n   * Listen for someone joining the channel.\n   */\n  joining(e) {\n    return this;\n  }\n  /**\n   * Send a whisper event to other clients in the channel.\n   */\n  whisper(e, t) {\n    return this;\n  }\n  /**\n   * Listen for someone leaving the channel.\n   */\n  leaving(e) {\n    return this;\n  }\n}\nconst c = class c {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e) {\n    this.setOptions(e), this.connect();\n  }\n  /**\n   * Merge the custom options with the defaults.\n   */\n  setOptions(e) {\n    this.options = {\n      ...c._defaultOptions,\n      ...e,\n      broadcaster: e.broadcaster\n    };\n    let t = this.csrfToken();\n    t && (this.options.auth.headers[\"X-CSRF-TOKEN\"] = t, this.options.userAuthentication.headers[\"X-CSRF-TOKEN\"] = t), t = this.options.bearerToken, t && (this.options.auth.headers.Authorization = \"Bearer \" + t, this.options.userAuthentication.headers.Authorization = \"Bearer \" + t);\n  }\n  /**\n   * Extract the CSRF token from the page.\n   */\n  csrfToken() {\n    var e, t;\n    return typeof window < \"u\" && (e = window.Laravel) != null && e.csrfToken ? window.Laravel.csrfToken : this.options.csrfToken ? this.options.csrfToken : typeof document < \"u\" && typeof document.querySelector == \"function\" ? ((t = document.querySelector('meta[name=\"csrf-token\"]')) == null ? void 0 : t.getAttribute(\"content\")) ?? null : null;\n  }\n};\nc._defaultOptions = {\n  auth: {\n    headers: {}\n  },\n  authEndpoint: \"/broadcasting/auth\",\n  userAuthentication: {\n    endpoint: \"/broadcasting/user-auth\",\n    headers: {}\n  },\n  csrfToken: null,\n  bearerToken: null,\n  host: null,\n  key: null,\n  namespace: \"App.Events\"\n};\nlet i = c;\nclass o extends i {\n  constructor() {\n    super(...arguments), this.channels = {};\n  }\n  /**\n   * Create a fresh Pusher connection.\n   */\n  connect() {\n    if (typeof this.options.client < \"u\") this.pusher = this.options.client;else if (this.options.Pusher) this.pusher = new this.options.Pusher(this.options.key, this.options);else if (typeof window < \"u\" && typeof window.Pusher < \"u\") this.pusher = new window.Pusher(this.options.key, this.options);else throw new Error(\"Pusher client not found. Should be globally available or passed via options.client\");\n  }\n  /**\n   * Sign in the user via Pusher user authentication (https://pusher.com/docs/channels/using_channels/user-authentication/).\n   */\n  signin() {\n    this.pusher.signin();\n  }\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return this.channel(e).listen(t, s);\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return this.channels[e] || (this.channels[e] = new u(this.pusher, e, this.options)), this.channels[e];\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  privateChannel(e) {\n    return this.channels[\"private-\" + e] || (this.channels[\"private-\" + e] = new f(this.pusher, \"private-\" + e, this.options)), this.channels[\"private-\" + e];\n  }\n  /**\n   * Get a private encrypted channel instance by name.\n   */\n  encryptedPrivateChannel(e) {\n    return this.channels[\"private-encrypted-\" + e] || (this.channels[\"private-encrypted-\" + e] = new g(this.pusher, \"private-encrypted-\" + e, this.options)), this.channels[\"private-encrypted-\" + e];\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  presenceChannel(e) {\n    return this.channels[\"presence-\" + e] || (this.channels[\"presence-\" + e] = new y(this.pusher, \"presence-\" + e, this.options)), this.channels[\"presence-\" + e];\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {\n    [e, \"private-\" + e, \"private-encrypted-\" + e, \"presence-\" + e].forEach(s => {\n      this.leaveChannel(s);\n    });\n  }\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {\n    this.channels[e] && (this.channels[e].unsubscribe(), delete this.channels[e]);\n  }\n  /**\n   * Get the socket ID for the connection.\n   */\n  socketId() {\n    return this.pusher.connection.socket_id;\n  }\n  /**\n   * Disconnect Pusher connection.\n   */\n  disconnect() {\n    this.pusher.disconnect();\n  }\n}\nclass I extends i {\n  constructor() {\n    super(...arguments), this.channels = {};\n  }\n  /**\n   * Create a fresh Socket.io connection.\n   */\n  connect() {\n    let e = this.getSocketIO();\n    this.socket = e(this.options.host ?? void 0, this.options), this.socket.io.on(\"reconnect\", () => {\n      Object.values(this.channels).forEach(t => {\n        t.subscribe();\n      });\n    });\n  }\n  /**\n   * Get socket.io module from global scope or options.\n   */\n  getSocketIO() {\n    if (typeof this.options.client < \"u\") return this.options.client;\n    if (typeof window < \"u\" && typeof window.io < \"u\") return window.io;\n    throw new Error(\"Socket.io client not found. Should be globally available or passed via options.client\");\n  }\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return this.channel(e).listen(t, s);\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return this.channels[e] || (this.channels[e] = new b(this.socket, e, this.options)), this.channels[e];\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  privateChannel(e) {\n    return this.channels[\"private-\" + e] || (this.channels[\"private-\" + e] = new v(this.socket, \"private-\" + e, this.options)), this.channels[\"private-\" + e];\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  presenceChannel(e) {\n    return this.channels[\"presence-\" + e] || (this.channels[\"presence-\" + e] = new m(this.socket, \"presence-\" + e, this.options)), this.channels[\"presence-\" + e];\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {\n    [e, \"private-\" + e, \"presence-\" + e].forEach(s => {\n      this.leaveChannel(s);\n    });\n  }\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {\n    this.channels[e] && (this.channels[e].unsubscribe(), delete this.channels[e]);\n  }\n  /**\n   * Get the socket ID for the connection.\n   */\n  socketId() {\n    return this.socket.id;\n  }\n  /**\n   * Disconnect Socketio connection.\n   */\n  disconnect() {\n    this.socket.disconnect();\n  }\n}\nclass p extends i {\n  constructor() {\n    super(...arguments), this.channels = {};\n  }\n  /**\n   * Create a fresh connection.\n   */\n  connect() {}\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return new h();\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return new h();\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  privateChannel(e) {\n    return new k();\n  }\n  /**\n   * Get a private encrypted channel instance by name.\n   */\n  encryptedPrivateChannel(e) {\n    return new _();\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  presenceChannel(e) {\n    return new C();\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {}\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {}\n  /**\n   * Get the socket ID for the connection.\n   */\n  socketId() {\n    return \"fake-socket-id\";\n  }\n  /**\n   * Disconnect the connection.\n   */\n  disconnect() {}\n}\nclass E {\n  /**\n   * Create a new class instance.\n   */\n  constructor(e) {\n    this.options = e, this.connect(), this.options.withoutInterceptors || this.registerInterceptors();\n  }\n  /**\n   * Get a channel instance by name.\n   */\n  channel(e) {\n    return this.connector.channel(e);\n  }\n  /**\n   * Create a new connection.\n   */\n  connect() {\n    if (this.options.broadcaster === \"reverb\") this.connector = new o({\n      ...this.options,\n      cluster: \"\"\n    });else if (this.options.broadcaster === \"pusher\") this.connector = new o(this.options);else if (this.options.broadcaster === \"ably\") this.connector = new o({\n      ...this.options,\n      cluster: \"\",\n      broadcaster: \"pusher\"\n    });else if (this.options.broadcaster === \"socket.io\") this.connector = new I(this.options);else if (this.options.broadcaster === \"null\") this.connector = new p(this.options);else if (typeof this.options.broadcaster == \"function\" && w(this.options.broadcaster)) this.connector = new this.options.broadcaster(this.options);else throw new Error(`Broadcaster ${typeof this.options.broadcaster} ${String(this.options.broadcaster)} is not supported.`);\n  }\n  /**\n   * Disconnect from the Echo server.\n   */\n  disconnect() {\n    this.connector.disconnect();\n  }\n  /**\n   * Get a presence channel instance by name.\n   */\n  join(e) {\n    return this.connector.presenceChannel(e);\n  }\n  /**\n   * Leave the given channel, as well as its private and presence variants.\n   */\n  leave(e) {\n    this.connector.leave(e);\n  }\n  /**\n   * Leave the given channel.\n   */\n  leaveChannel(e) {\n    this.connector.leaveChannel(e);\n  }\n  /**\n   * Leave all channels.\n   */\n  leaveAllChannels() {\n    for (const e in this.connector.channels) this.leaveChannel(e);\n  }\n  /**\n   * Listen for an event on a channel instance.\n   */\n  listen(e, t, s) {\n    return this.connector.listen(e, t, s);\n  }\n  /**\n   * Get a private channel instance by name.\n   */\n  private(e) {\n    return this.connector.privateChannel(e);\n  }\n  /**\n   * Get a private encrypted channel instance by name.\n   */\n  encryptedPrivate(e) {\n    if (this.connectorSupportsEncryptedPrivateChannels(this.connector)) return this.connector.encryptedPrivateChannel(e);\n    throw new Error(`Broadcaster ${typeof this.options.broadcaster} ${String(this.options.broadcaster)} does not support encrypted private channels.`);\n  }\n  connectorSupportsEncryptedPrivateChannels(e) {\n    return e instanceof o || e instanceof p;\n  }\n  /**\n   * Get the Socket ID for the connection.\n   */\n  socketId() {\n    return this.connector.socketId();\n  }\n  /**\n   * Register 3rd party request interceptiors. These are used to automatically\n   * send a connections socket id to a Laravel app with a X-Socket-Id header.\n   */\n  registerInterceptors() {\n    typeof Vue < \"u\" && Vue != null && Vue.http && this.registerVueRequestInterceptor(), typeof axios == \"function\" && this.registerAxiosRequestInterceptor(), typeof jQuery == \"function\" && this.registerjQueryAjaxSetup(), typeof Turbo == \"object\" && this.registerTurboRequestInterceptor();\n  }\n  /**\n   * Register a Vue HTTP interceptor to add the X-Socket-ID header.\n   */\n  registerVueRequestInterceptor() {\n    Vue.http.interceptors.push((e, t) => {\n      this.socketId() && e.headers.set(\"X-Socket-ID\", this.socketId()), t();\n    });\n  }\n  /**\n   * Register an Axios HTTP interceptor to add the X-Socket-ID header.\n   */\n  registerAxiosRequestInterceptor() {\n    axios.interceptors.request.use(e => (this.socketId() && (e.headers[\"X-Socket-Id\"] = this.socketId()), e));\n  }\n  /**\n   * Register jQuery AjaxPrefilter to add the X-Socket-ID header.\n   */\n  registerjQueryAjaxSetup() {\n    typeof jQuery.ajax < \"u\" && jQuery.ajaxPrefilter((e, t, s) => {\n      this.socketId() && s.setRequestHeader(\"X-Socket-Id\", this.socketId());\n    });\n  }\n  /**\n   * Register the Turbo Request interceptor to add the X-Socket-ID header.\n   */\n  registerTurboRequestInterceptor() {\n    document.addEventListener(\"turbo:before-fetch-request\", e => {\n      e.detail.fetchOptions.headers[\"X-Socket-Id\"] = this.socketId();\n    });\n  }\n}\nexport { l as Channel, i as Connector, d as EventFormatter, E as default };","map":{"version":3,"names":["l","listenForWhisper","e","t","listen","notification","stopListeningForWhisper","stopListening","d","constructor","namespace","format","includes","charAt","substring","replace","setNamespace","w","n","Error","message","u","s","name","pusher","options","eventFormatter","subscribe","subscription","unsubscribe","on","listenToAll","bind_global","startsWith","r","String","a","length","unbind","stopListeningToAll","unbind_global","subscribed","error","bind","f","whisper","channels","trigger","g","y","here","Object","keys","members","map","joining","info","leaving","b","events","listeners","socket","emit","channel","auth","unbindEvent","forEach","push","filter","removeListener","v","event","data","m","user_info","h","k","_","C","c","setOptions","connect","_defaultOptions","broadcaster","csrfToken","headers","userAuthentication","bearerToken","Authorization","window","Laravel","document","querySelector","getAttribute","authEndpoint","endpoint","host","key","i","o","arguments","client","Pusher","signin","privateChannel","encryptedPrivateChannel","presenceChannel","leave","leaveChannel","socketId","connection","socket_id","disconnect","I","getSocketIO","io","values","id","p","E","withoutInterceptors","registerInterceptors","connector","cluster","join","leaveAllChannels","private","encryptedPrivate","connectorSupportsEncryptedPrivateChannels","Vue","http","registerVueRequestInterceptor","axios","registerAxiosRequestInterceptor","jQuery","registerjQueryAjaxSetup","Turbo","registerTurboRequestInterceptor","interceptors","set","request","use","ajax","ajaxPrefilter","setRequestHeader","addEventListener","detail","fetchOptions"],"sources":["C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\util\\event-formatter.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\util\\index.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-private-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-encrypted-private-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\pusher-presence-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\socketio-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\socketio-private-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\socketio-presence-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-private-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-encrypted-private-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\channel\\null-presence-channel.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\connector.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\pusher-connector.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\socketio-connector.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\connector\\null-connector.ts","C:\\xampp\\htdocs\\quizbmTest2\\quizbm-frontend\\node_modules\\laravel-echo\\src\\echo.ts"],"sourcesContent":["import type { EchoOptionsWithDefaults } from \"../connector\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a basic channel.\n */\nexport abstract class Channel {\n    /**\n     * The Echo options.\n     */\n    options: EchoOptionsWithDefaults<BroadcastDriver>;\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    abstract listen(event: string, callback: CallableFunction): this;\n\n    /**\n     * Listen for a whisper event on the channel instance.\n     */\n    listenForWhisper(event: string, callback: CallableFunction): this {\n        return this.listen(\".client-\" + event, callback);\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    notification(callback: CallableFunction): this {\n        return this.listen(\n            \".Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated\",\n            callback,\n        );\n    }\n\n    /**\n     * Stop listening to an event on the channel instance.\n     */\n    abstract stopListening(event: string, callback?: CallableFunction): this;\n\n    /**\n     * Stop listening for a whisper event on the channel instance.\n     */\n    stopListeningForWhisper(event: string, callback?: CallableFunction): this {\n        return this.stopListening(\".client-\" + event, callback);\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    abstract subscribed(callback: CallableFunction): this;\n\n    /**\n     * Register a callback to be called anytime an error occurs.\n     */\n    abstract error(callback: CallableFunction): this;\n}\n","/**\n * Event name formatter\n */\nexport class EventFormatter {\n    /**\n     * Create a new class instance.\n     */\n    constructor(private namespace: string | boolean | undefined) {\n        //\n    }\n\n    /**\n     * Format the given event name.\n     */\n    format(event: string): string {\n        if ([\".\", \"\\\\\"].includes(event.charAt(0))) {\n            return event.substring(1);\n        } else if (this.namespace) {\n            event = this.namespace + \".\" + event;\n        }\n\n        return event.replace(/\\./g, \"\\\\\");\n    }\n\n    /**\n     * Set the event namespace.\n     */\n    setNamespace(value: string | boolean): void {\n        this.namespace = value;\n    }\n}\n","function isConstructor(obj: unknown): obj is new (...args: any[]) => any {\n    try {\n        new (obj as new (...args: any[]) => any)();\n    } catch (err) {\n        if (\n            err instanceof Error &&\n            err.message.includes(\"is not a constructor\")\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport { isConstructor };\nexport * from \"./event-formatter\";\n","import { EventFormatter } from \"../util\";\nimport { Channel } from \"./channel\";\nimport type Pusher from \"pusher-js\";\nimport type { Channel as BasePusherChannel } from \"pusher-js\";\nimport type { EchoOptionsWithDefaults } from \"../connector\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher channel.\n */\nexport class PusherChannel<\n    TBroadcastDriver extends BroadcastDriver,\n> extends Channel {\n    /**\n     * The Pusher client instance.\n     */\n    pusher: Pusher;\n\n    /**\n     * The name of the channel.\n     */\n    name: string;\n\n    /**\n     * The event formatter.\n     */\n    eventFormatter: EventFormatter;\n\n    /**\n     * The subscription of the channel.\n     */\n    subscription: BasePusherChannel;\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(\n        pusher: Pusher,\n        name: string,\n        options: EchoOptionsWithDefaults<TBroadcastDriver>,\n    ) {\n        super();\n\n        this.name = name;\n        this.pusher = pusher;\n        this.options = options;\n        this.eventFormatter = new EventFormatter(this.options.namespace);\n\n        this.subscribe();\n    }\n\n    /**\n     * Subscribe to a Pusher channel.\n     */\n    subscribe(): void {\n        this.subscription = this.pusher.subscribe(this.name);\n    }\n\n    /**\n     * Unsubscribe from a Pusher channel.\n     */\n    unsubscribe(): void {\n        this.pusher.unsubscribe(this.name);\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    listen(event: string, callback: CallableFunction): this {\n        this.on(this.eventFormatter.format(event), callback);\n\n        return this;\n    }\n\n    /**\n     * Listen for all events on the channel instance.\n     */\n    listenToAll(callback: CallableFunction): this {\n        this.subscription.bind_global((event: string, data: unknown) => {\n            if (event.startsWith(\"pusher:\")) {\n                return;\n            }\n\n            let namespace = String(this.options.namespace ?? \"\").replace(\n                /\\./g,\n                \"\\\\\",\n            );\n\n            let formattedEvent = event.startsWith(namespace)\n                ? event.substring(namespace.length + 1)\n                : \".\" + event;\n\n            callback(formattedEvent, data);\n        });\n\n        return this;\n    }\n\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n    stopListening(event: string, callback?: CallableFunction): this {\n        if (callback) {\n            this.subscription.unbind(\n                this.eventFormatter.format(event),\n                callback,\n            );\n        } else {\n            this.subscription.unbind(this.eventFormatter.format(event));\n        }\n\n        return this;\n    }\n\n    /**\n     * Stop listening for all events on the channel instance.\n     */\n    stopListeningToAll(callback?: CallableFunction): this {\n        if (callback) {\n            this.subscription.unbind_global(callback);\n        } else {\n            this.subscription.unbind_global();\n        }\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    subscribed(callback: CallableFunction): this {\n        this.on(\"pusher:subscription_succeeded\", () => {\n            callback();\n        });\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription error occurs.\n     */\n    error(callback: CallableFunction): this {\n        this.on(\"pusher:subscription_error\", (status: Record<string, any>) => {\n            callback(status);\n        });\n\n        return this;\n    }\n\n    /**\n     * Bind a channel to an event.\n     */\n    on(event: string, callback: CallableFunction): this {\n        this.subscription.bind(event, callback);\n\n        return this;\n    }\n}\n","import { PusherChannel } from \"./pusher-channel\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher private channel.\n */\nexport class PusherPrivateChannel<\n    TBroadcastDriver extends BroadcastDriver,\n> extends PusherChannel<TBroadcastDriver> {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: Record<any, any>): this {\n        this.pusher.channels.channels[this.name].trigger(\n            `client-${eventName}`,\n            data,\n        );\n\n        return this;\n    }\n}\n","import { PusherChannel } from \"./pusher-channel\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher private channel.\n */\nexport class PusherEncryptedPrivateChannel<\n    TBroadcastDriver extends BroadcastDriver,\n> extends PusherChannel<TBroadcastDriver> {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: Record<any, any>): this {\n        this.pusher.channels.channels[this.name].trigger(\n            `client-${eventName}`,\n            data,\n        );\n\n        return this;\n    }\n}\n","import type { PresenceChannel } from \"./presence-channel\";\nimport { PusherPrivateChannel } from \"./pusher-private-channel\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Pusher presence channel.\n */\nexport class PusherPresenceChannel<TBroadcastDriver extends BroadcastDriver>\n    extends PusherPrivateChannel<TBroadcastDriver>\n    implements PresenceChannel\n{\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    here(callback: CallableFunction): this {\n        this.on(\"pusher:subscription_succeeded\", (data: Record<any, any>) => {\n            callback(Object.keys(data.members).map((k) => data.members[k]));\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen for someone joining the channel.\n     */\n    joining(callback: CallableFunction): this {\n        this.on(\"pusher:member_added\", (member: Record<any, any>) => {\n            callback(member.info);\n        });\n\n        return this;\n    }\n\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: Record<any, any>): this {\n        this.pusher.channels.channels[this.name].trigger(\n            `client-${eventName}`,\n            data,\n        );\n\n        return this;\n    }\n\n    /**\n     * Listen for someone leaving the channel.\n     */\n    leaving(callback: CallableFunction): this {\n        this.on(\"pusher:member_removed\", (member: Record<any, any>) => {\n            callback(member.info);\n        });\n\n        return this;\n    }\n}\n","import { EventFormatter } from \"../util\";\nimport { Channel } from \"./channel\";\nimport type { Socket } from \"socket.io-client\";\nimport type { EchoOptionsWithDefaults } from \"../connector\";\nimport type { BroadcastDriver } from \"../echo\";\n\n/**\n * This class represents a Socket.io channel.\n */\nexport class SocketIoChannel extends Channel {\n    /**\n     * The Socket.io client instance.\n     */\n    socket: Socket;\n\n    /**\n     * The name of the channel.\n     */\n    name: string;\n\n    /**\n     * The event formatter.\n     */\n    eventFormatter: EventFormatter;\n\n    /**\n     * The event callbacks applied to the socket.\n     */\n    events: Record<string, any> = {};\n\n    /**\n     * User supplied callbacks for events on this channel.\n     */\n    private listeners: Record<string, CallableFunction[]> = {};\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(\n        socket: Socket,\n        name: string,\n        options: EchoOptionsWithDefaults<BroadcastDriver>,\n    ) {\n        super();\n\n        this.name = name;\n        this.socket = socket;\n        this.options = options;\n        this.eventFormatter = new EventFormatter(this.options.namespace);\n\n        this.subscribe();\n    }\n\n    /**\n     * Subscribe to a Socket.io channel.\n     */\n    subscribe(): void {\n        this.socket.emit(\"subscribe\", {\n            channel: this.name,\n            auth: this.options.auth || {},\n        });\n    }\n\n    /**\n     * Unsubscribe from channel and ubind event callbacks.\n     */\n    unsubscribe(): void {\n        this.unbind();\n\n        this.socket.emit(\"unsubscribe\", {\n            channel: this.name,\n            auth: this.options.auth || {},\n        });\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    listen(event: string, callback: CallableFunction): this {\n        this.on(this.eventFormatter.format(event), callback);\n\n        return this;\n    }\n\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n    stopListening(event: string, callback?: CallableFunction): this {\n        this.unbindEvent(this.eventFormatter.format(event), callback);\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    subscribed(callback: CallableFunction): this {\n        this.on(\"connect\", (socket: Socket) => {\n            callback(socket);\n        });\n\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime an error occurs.\n     */\n    error(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Bind the channel's socket to an event and store the callback.\n     */\n    on(event: string, callback: CallableFunction): this {\n        this.listeners[event] = this.listeners[event] || [];\n\n        if (!this.events[event]) {\n            this.events[event] = (channel: string, data: unknown) => {\n                if (this.name === channel && this.listeners[event]) {\n                    this.listeners[event].forEach((cb) => cb(data));\n                }\n            };\n\n            this.socket.on(event, this.events[event]);\n        }\n\n        this.listeners[event].push(callback);\n\n        return this;\n    }\n\n    /**\n     * Unbind the channel's socket from all stored event callbacks.\n     */\n    unbind(): void {\n        Object.keys(this.events).forEach((event) => {\n            this.unbindEvent(event);\n        });\n    }\n\n    /**\n     * Unbind the listeners for the given event.\n     */\n    protected unbindEvent(event: string, callback?: CallableFunction): void {\n        this.listeners[event] = this.listeners[event] || [];\n\n        if (callback) {\n            this.listeners[event] = this.listeners[event].filter(\n                (cb) => cb !== callback,\n            );\n        }\n\n        if (!callback || this.listeners[event].length === 0) {\n            if (this.events[event]) {\n                this.socket.removeListener(event, this.events[event]);\n\n                delete this.events[event];\n            }\n\n            delete this.listeners[event];\n        }\n    }\n}\n","import { SocketIoChannel } from \"./socketio-channel\";\n\n/**\n * This class represents a Socket.io private channel.\n */\nexport class SocketIoPrivateChannel extends SocketIoChannel {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: unknown): this {\n        this.socket.emit(\"client event\", {\n            channel: this.name,\n            event: `client-${eventName}`,\n            data: data,\n        });\n\n        return this;\n    }\n}\n","import type { PresenceChannel } from \"./presence-channel\";\nimport { SocketIoPrivateChannel } from \"./socketio-private-channel\";\n\n/**\n * This class represents a Socket.io presence channel.\n */\nexport class SocketIoPresenceChannel\n    extends SocketIoPrivateChannel\n    implements PresenceChannel\n{\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    here(callback: CallableFunction): this {\n        this.on(\"presence:subscribed\", (members: Record<string, any>[]) => {\n            callback(members.map((m) => m.user_info));\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen for someone joining the channel.\n     */\n    joining(callback: CallableFunction): this {\n        this.on(\"presence:joining\", (member: Record<string, any>) =>\n            callback(member.user_info),\n        );\n\n        return this;\n    }\n\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(eventName: string, data: unknown): this {\n        this.socket.emit(\"client event\", {\n            channel: this.name,\n            event: `client-${eventName}`,\n            data: data,\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen for someone leaving the channel.\n     */\n    leaving(callback: CallableFunction): this {\n        this.on(\"presence:leaving\", (member: Record<string, any>) =>\n            callback(member.user_info),\n        );\n\n        return this;\n    }\n}\n","import { Channel } from \"./channel\";\n\n/**\n * This class represents a null channel.\n */\nexport class NullChannel extends Channel {\n    /**\n     * Subscribe to a channel.\n     */\n    subscribe(): void {\n        //\n    }\n\n    /**\n     * Unsubscribe from a channel.\n     */\n    unsubscribe(): void {\n        //\n    }\n\n    /**\n     * Listen for an event on the channel instance.\n     */\n    listen(_event: string, _callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Listen for all events on the channel instance.\n     */\n    listenToAll(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Stop listening for an event on the channel instance.\n     */\n    stopListening(_event: string, _callback?: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime a subscription succeeds.\n     */\n    subscribed(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Register a callback to be called anytime an error occurs.\n     */\n    error(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Bind a channel to an event.\n     */\n    on(_event: string, _callback: CallableFunction): this {\n        return this;\n    }\n}\n","import { NullChannel } from \"./null-channel\";\n\n/**\n * This class represents a null private channel.\n */\nexport class NullPrivateChannel extends NullChannel {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(_eventName: string, _data: Record<any, any>): this {\n        return this;\n    }\n}\n","import { NullChannel } from \"./null-channel\";\n\n/**\n * This class represents a null private channel.\n */\nexport class NullEncryptedPrivateChannel extends NullChannel {\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(_eventName: string, _data: Record<any, any>): this {\n        return this;\n    }\n}\n","import { NullPrivateChannel } from \"./null-private-channel\";\nimport type { PresenceChannel } from \"./presence-channel\";\n\n/**\n * This class represents a null presence channel.\n */\nexport class NullPresenceChannel\n    extends NullPrivateChannel\n    implements PresenceChannel\n{\n    /**\n     * Register a callback to be called anytime the member list changes.\n     */\n    here(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Listen for someone joining the channel.\n     */\n    joining(_callback: CallableFunction): this {\n        return this;\n    }\n\n    /**\n     * Send a whisper event to other clients in the channel.\n     */\n    whisper(_eventName: string, _data: Record<any, any>): this {\n        return this;\n    }\n\n    /**\n     * Listen for someone leaving the channel.\n     */\n    leaving(_callback: CallableFunction): this {\n        return this;\n    }\n}\n","/// <reference types=\"window\" />\n\nimport type { Channel, PresenceChannel } from \"../channel\";\nimport type { BroadcastDriver, EchoOptions } from \"../echo\";\n\nexport type EchoOptionsWithDefaults<TBroadcaster extends BroadcastDriver> = {\n    broadcaster: TBroadcaster;\n    auth: {\n        headers: Record<string, string>;\n    };\n    authEndpoint: string;\n    userAuthentication: {\n        endpoint: string;\n        headers: Record<string, string>;\n    };\n    csrfToken: string | null;\n    bearerToken: string | null;\n    host: string | null;\n    key: string | null;\n    namespace: string | false;\n\n    [key: string]: any;\n};\n\nexport abstract class Connector<\n    TBroadcastDriver extends BroadcastDriver,\n    TPublic extends Channel,\n    TPrivate extends Channel,\n    TPresence extends PresenceChannel,\n> {\n    /**\n     * Default connector options.\n     */\n    public static readonly _defaultOptions = {\n        auth: {\n            headers: {},\n        },\n        authEndpoint: \"/broadcasting/auth\",\n        userAuthentication: {\n            endpoint: \"/broadcasting/user-auth\",\n            headers: {},\n        },\n        csrfToken: null,\n        bearerToken: null,\n        host: null,\n        key: null,\n        namespace: \"App.Events\",\n    } as const;\n\n    /**\n     * Connector options.\n     */\n    options: EchoOptionsWithDefaults<TBroadcastDriver>;\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(options: EchoOptions<TBroadcastDriver>) {\n        this.setOptions(options);\n        this.connect();\n    }\n\n    /**\n     * Merge the custom options with the defaults.\n     */\n    protected setOptions(options: EchoOptions<TBroadcastDriver>): void {\n        this.options = {\n            ...Connector._defaultOptions,\n            ...options,\n            broadcaster: options.broadcaster as TBroadcastDriver,\n        };\n\n        let token = this.csrfToken();\n\n        if (token) {\n            this.options.auth.headers[\"X-CSRF-TOKEN\"] = token;\n            this.options.userAuthentication.headers[\"X-CSRF-TOKEN\"] = token;\n        }\n\n        token = this.options.bearerToken;\n\n        if (token) {\n            this.options.auth.headers[\"Authorization\"] = \"Bearer \" + token;\n            this.options.userAuthentication.headers[\"Authorization\"] =\n                \"Bearer \" + token;\n        }\n    }\n\n    /**\n     * Extract the CSRF token from the page.\n     */\n    protected csrfToken(): null | string {\n        if (typeof window !== \"undefined\" && window.Laravel?.csrfToken) {\n            return window.Laravel.csrfToken;\n        }\n\n        if (this.options.csrfToken) {\n            return this.options.csrfToken;\n        }\n\n        if (\n            typeof document !== \"undefined\" &&\n            typeof document.querySelector === \"function\"\n        ) {\n            return (\n                document\n                    .querySelector('meta[name=\"csrf-token\"]')\n                    ?.getAttribute(\"content\") ?? null\n            );\n        }\n\n        return null;\n    }\n\n    /**\n     * Create a fresh connection.\n     */\n    abstract connect(): void;\n\n    /**\n     * Get a channel instance by name.\n     */\n    abstract channel(channel: string): TPublic;\n\n    /**\n     * Get a private channel instance by name.\n     */\n    abstract privateChannel(channel: string): TPrivate;\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    abstract presenceChannel(channel: string): TPresence;\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    abstract leave(channel: string): void;\n\n    /**\n     * Leave the given channel.\n     */\n    abstract leaveChannel(channel: string): void;\n\n    /**\n     * Get the socket_id of the connection.\n     */\n    abstract socketId(): string | undefined;\n\n    /**\n     * Disconnect from the Echo server.\n     */\n    abstract disconnect(): void;\n}\n","import type Pusher from \"pusher-js\";\nimport type { Options as PusherJsOptions } from \"pusher-js\";\nimport {\n    PusherChannel,\n    PusherEncryptedPrivateChannel,\n    PusherPresenceChannel,\n    PusherPrivateChannel,\n} from \"../channel\";\nimport type { BroadcastDriver } from \"../echo\";\nimport { Connector, type EchoOptionsWithDefaults } from \"./connector\";\n\ntype AnyPusherChannel =\n    | PusherChannel<BroadcastDriver>\n    | PusherPrivateChannel<BroadcastDriver>\n    | PusherEncryptedPrivateChannel<BroadcastDriver>\n    | PusherPresenceChannel<BroadcastDriver>;\n\nexport type PusherOptions<TBroadcastDriver extends BroadcastDriver> =\n    EchoOptionsWithDefaults<TBroadcastDriver> & {\n        key: string;\n        Pusher?: typeof Pusher;\n    } & PusherJsOptions;\n\n/**\n * This class creates a connector to Pusher.\n */\nexport class PusherConnector<\n    TBroadcastDriver extends BroadcastDriver,\n> extends Connector<\n    TBroadcastDriver,\n    PusherChannel<TBroadcastDriver>,\n    PusherPrivateChannel<TBroadcastDriver>,\n    PusherPresenceChannel<TBroadcastDriver>\n> {\n    /**\n     * The Pusher instance.\n     */\n    pusher: Pusher;\n\n    /**\n     * All of the subscribed channel names.\n     */\n    channels: Record<string, AnyPusherChannel> = {};\n\n    declare options: PusherOptions<TBroadcastDriver>;\n\n    /**\n     * Create a fresh Pusher connection.\n     */\n    connect(): void {\n        if (typeof this.options.client !== \"undefined\") {\n            this.pusher = this.options.client as Pusher;\n        } else if (this.options.Pusher) {\n            this.pusher = new this.options.Pusher(\n                this.options.key,\n                this.options,\n            );\n        } else if (\n            typeof window !== \"undefined\" &&\n            typeof window.Pusher !== \"undefined\"\n        ) {\n            this.pusher = new window.Pusher(this.options.key, this.options);\n        } else {\n            throw new Error(\n                \"Pusher client not found. Should be globally available or passed via options.client\",\n            );\n        }\n    }\n\n    /**\n     * Sign in the user via Pusher user authentication (https://pusher.com/docs/channels/using_channels/user-authentication/).\n     */\n    signin(): void {\n        this.pusher.signin();\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        name: string,\n        event: string,\n        callback: CallableFunction,\n    ): AnyPusherChannel {\n        return this.channel(name).listen(event, callback);\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(name: string): AnyPusherChannel {\n        if (!this.channels[name]) {\n            this.channels[name] = new PusherChannel(\n                this.pusher,\n                name,\n                this.options,\n            );\n        }\n\n        return this.channels[name];\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    privateChannel(name: string): PusherPrivateChannel<TBroadcastDriver> {\n        if (!this.channels[\"private-\" + name]) {\n            this.channels[\"private-\" + name] = new PusherPrivateChannel(\n                this.pusher,\n                \"private-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\n            \"private-\" + name\n        ] as PusherPrivateChannel<TBroadcastDriver>;\n    }\n\n    /**\n     * Get a private encrypted channel instance by name.\n     */\n    encryptedPrivateChannel(\n        name: string,\n    ): PusherEncryptedPrivateChannel<TBroadcastDriver> {\n        if (!this.channels[\"private-encrypted-\" + name]) {\n            this.channels[\"private-encrypted-\" + name] =\n                new PusherEncryptedPrivateChannel(\n                    this.pusher,\n                    \"private-encrypted-\" + name,\n                    this.options,\n                );\n        }\n\n        return this.channels[\n            \"private-encrypted-\" + name\n        ] as PusherEncryptedPrivateChannel<TBroadcastDriver>;\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    presenceChannel(name: string): PusherPresenceChannel<TBroadcastDriver> {\n        if (!this.channels[\"presence-\" + name]) {\n            this.channels[\"presence-\" + name] = new PusherPresenceChannel(\n                this.pusher,\n                \"presence-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\n            \"presence-\" + name\n        ] as PusherPresenceChannel<TBroadcastDriver>;\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(name: string): void {\n        let channels = [\n            name,\n            \"private-\" + name,\n            \"private-encrypted-\" + name,\n            \"presence-\" + name,\n        ];\n\n        channels.forEach((name: string) => {\n            this.leaveChannel(name);\n        });\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(name: string): void {\n        if (this.channels[name]) {\n            this.channels[name].unsubscribe();\n\n            delete this.channels[name];\n        }\n    }\n\n    /**\n     * Get the socket ID for the connection.\n     */\n    socketId(): string {\n        return this.pusher.connection.socket_id;\n    }\n\n    /**\n     * Disconnect Pusher connection.\n     */\n    disconnect(): void {\n        this.pusher.disconnect();\n    }\n}\n","import { Connector } from \"./connector\";\nimport {\n    SocketIoChannel,\n    SocketIoPrivateChannel,\n    SocketIoPresenceChannel,\n} from \"../channel\";\nimport type {\n    io,\n    ManagerOptions,\n    Socket,\n    SocketOptions,\n} from \"socket.io-client\";\n\ntype AnySocketIoChannel =\n    | SocketIoChannel\n    | SocketIoPrivateChannel\n    | SocketIoPresenceChannel;\n\n/**\n * This class creates a connector to a Socket.io server.\n */\nexport class SocketIoConnector extends Connector<\n    \"socket.io\",\n    SocketIoChannel,\n    SocketIoPrivateChannel,\n    SocketIoPresenceChannel\n> {\n    /**\n     * The Socket.io connection instance.\n     */\n    socket: Socket;\n\n    /**\n     * All of the subscribed channel names.\n     */\n    channels: { [name: string]: SocketIoChannel } = {};\n\n    /**\n     * Create a fresh Socket.io connection.\n     */\n    connect(): void {\n        let io = this.getSocketIO();\n\n        this.socket = io(\n            this.options.host ?? undefined,\n            this.options as Partial<ManagerOptions & SocketOptions>,\n        );\n\n        this.socket.io.on(\"reconnect\", () => {\n            Object.values(this.channels).forEach((channel) => {\n                channel.subscribe();\n            });\n        });\n    }\n\n    /**\n     * Get socket.io module from global scope or options.\n     */\n    getSocketIO(): typeof io {\n        if (typeof this.options.client !== \"undefined\") {\n            return this.options.client as typeof io;\n        }\n\n        if (typeof window !== \"undefined\" && typeof window.io !== \"undefined\") {\n            return window.io;\n        }\n\n        throw new Error(\n            \"Socket.io client not found. Should be globally available or passed via options.client\",\n        );\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        name: string,\n        event: string,\n        callback: CallableFunction,\n    ): AnySocketIoChannel {\n        return this.channel(name).listen(event, callback);\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(name: string): AnySocketIoChannel {\n        if (!this.channels[name]) {\n            this.channels[name] = new SocketIoChannel(\n                this.socket,\n                name,\n                this.options,\n            );\n        }\n\n        return this.channels[name];\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    privateChannel(name: string): SocketIoPrivateChannel {\n        if (!this.channels[\"private-\" + name]) {\n            this.channels[\"private-\" + name] = new SocketIoPrivateChannel(\n                this.socket,\n                \"private-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\"private-\" + name] as SocketIoPrivateChannel;\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    presenceChannel(name: string): SocketIoPresenceChannel {\n        if (!this.channels[\"presence-\" + name]) {\n            this.channels[\"presence-\" + name] = new SocketIoPresenceChannel(\n                this.socket,\n                \"presence-\" + name,\n                this.options,\n            );\n        }\n\n        return this.channels[\"presence-\" + name] as SocketIoPresenceChannel;\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(name: string): void {\n        let channels = [name, \"private-\" + name, \"presence-\" + name];\n\n        channels.forEach((name) => {\n            this.leaveChannel(name);\n        });\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(name: string): void {\n        if (this.channels[name]) {\n            this.channels[name].unsubscribe();\n\n            delete this.channels[name];\n        }\n    }\n\n    /**\n     * Get the socket ID for the connection.\n     */\n    socketId(): string | undefined {\n        return this.socket.id;\n    }\n\n    /**\n     * Disconnect Socketio connection.\n     */\n    disconnect(): void {\n        this.socket.disconnect();\n    }\n}\n","import { Connector } from \"./connector\";\nimport {\n    NullChannel,\n    NullPrivateChannel,\n    NullPresenceChannel,\n    NullEncryptedPrivateChannel,\n} from \"../channel\";\n\n/**\n * This class creates a null connector.\n */\nexport class NullConnector extends Connector<\n    \"null\",\n    NullChannel,\n    NullPrivateChannel,\n    NullPresenceChannel\n> {\n    /**\n     * All of the subscribed channel names.\n     */\n    channels: any = {};\n\n    /**\n     * Create a fresh connection.\n     */\n    connect(): void {\n        //\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        _name: string,\n        _event: string,\n        _callback: CallableFunction,\n    ): NullChannel {\n        return new NullChannel();\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(_name: string): NullChannel {\n        return new NullChannel();\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    privateChannel(_name: string): NullPrivateChannel {\n        return new NullPrivateChannel();\n    }\n\n    /**\n     * Get a private encrypted channel instance by name.\n     */\n    encryptedPrivateChannel(_name: string): NullEncryptedPrivateChannel {\n        return new NullEncryptedPrivateChannel();\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    presenceChannel(_name: string): NullPresenceChannel {\n        return new NullPresenceChannel();\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(_name: string): void {\n        //\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(_name: string): void {\n        //\n    }\n\n    /**\n     * Get the socket ID for the connection.\n     */\n    socketId(): string {\n        return \"fake-socket-id\";\n    }\n\n    /**\n     * Disconnect the connection.\n     */\n    disconnect(): void {\n        //\n    }\n}\n","import type { InternalAxiosRequestConfig } from \"axios\";\nimport {\n    Channel,\n    NullChannel,\n    NullEncryptedPrivateChannel,\n    NullPresenceChannel,\n    NullPrivateChannel,\n    PusherChannel,\n    PusherEncryptedPrivateChannel,\n    PusherPresenceChannel,\n    PusherPrivateChannel,\n    SocketIoChannel,\n    SocketIoPresenceChannel,\n    SocketIoPrivateChannel,\n    type PresenceChannel,\n} from \"./channel\";\nimport {\n    Connector,\n    NullConnector,\n    PusherConnector,\n    SocketIoConnector,\n    type PusherOptions,\n} from \"./connector\";\nimport { isConstructor } from \"./util\";\n\n/**\n * This class is the primary API for interacting with broadcasting.\n */\nexport default class Echo<T extends keyof Broadcaster> {\n    /**\n     * The broadcasting connector.\n     */\n    connector: Broadcaster[Exclude<T, \"function\">][\"connector\"];\n\n    /**\n     * The Echo options.\n     */\n    options: EchoOptions<T>;\n\n    /**\n     * Create a new class instance.\n     */\n    constructor(options: EchoOptions<T>) {\n        this.options = options;\n        this.connect();\n\n        if (!this.options.withoutInterceptors) {\n            this.registerInterceptors();\n        }\n    }\n\n    /**\n     * Get a channel instance by name.\n     */\n    channel(channel: string): Broadcaster[T][\"public\"] {\n        return this.connector.channel(channel);\n    }\n\n    /**\n     * Create a new connection.\n     */\n    connect(): void {\n        if (this.options.broadcaster === \"reverb\") {\n            this.connector = new PusherConnector<\"reverb\">({\n                ...this.options,\n                cluster: \"\",\n            });\n        } else if (this.options.broadcaster === \"pusher\") {\n            this.connector = new PusherConnector<\"pusher\">(this.options);\n        } else if (this.options.broadcaster === \"ably\") {\n            this.connector = new PusherConnector<\"pusher\">({\n                ...this.options,\n                cluster: \"\",\n                broadcaster: \"pusher\",\n            });\n        } else if (this.options.broadcaster === \"socket.io\") {\n            this.connector = new SocketIoConnector(this.options);\n        } else if (this.options.broadcaster === \"null\") {\n            this.connector = new NullConnector(this.options);\n        } else if (\n            typeof this.options.broadcaster === \"function\" &&\n            isConstructor(this.options.broadcaster)\n        ) {\n            this.connector = new this.options.broadcaster(this.options);\n        } else {\n            throw new Error(\n                `Broadcaster ${typeof this.options.broadcaster} ${String(this.options.broadcaster)} is not supported.`,\n            );\n        }\n    }\n\n    /**\n     * Disconnect from the Echo server.\n     */\n    disconnect(): void {\n        this.connector.disconnect();\n    }\n\n    /**\n     * Get a presence channel instance by name.\n     */\n    join(channel: string): Broadcaster[T][\"presence\"] {\n        return this.connector.presenceChannel(channel);\n    }\n\n    /**\n     * Leave the given channel, as well as its private and presence variants.\n     */\n    leave(channel: string): void {\n        this.connector.leave(channel);\n    }\n\n    /**\n     * Leave the given channel.\n     */\n    leaveChannel(channel: string): void {\n        this.connector.leaveChannel(channel);\n    }\n\n    /**\n     * Leave all channels.\n     */\n    leaveAllChannels(): void {\n        for (const channel in this.connector.channels) {\n            this.leaveChannel(channel);\n        }\n    }\n\n    /**\n     * Listen for an event on a channel instance.\n     */\n    listen(\n        channel: string,\n        event: string,\n        callback: CallableFunction,\n    ): Broadcaster[T][\"public\"] {\n        return this.connector.listen(channel, event, callback);\n    }\n\n    /**\n     * Get a private channel instance by name.\n     */\n    private(channel: string): Broadcaster[T][\"private\"] {\n        return this.connector.privateChannel(channel);\n    }\n\n    /**\n     * Get a private encrypted channel instance by name.\n     */\n    encryptedPrivate(channel: string): Broadcaster[T][\"encrypted\"] {\n        if (this.connectorSupportsEncryptedPrivateChannels(this.connector)) {\n            return this.connector.encryptedPrivateChannel(channel);\n        }\n\n        throw new Error(\n            `Broadcaster ${typeof this.options.broadcaster} ${String(\n                this.options.broadcaster,\n            )} does not support encrypted private channels.`,\n        );\n    }\n\n    private connectorSupportsEncryptedPrivateChannels(\n        connector: unknown,\n    ): connector is PusherConnector<any> | NullConnector {\n        return (\n            connector instanceof PusherConnector ||\n            connector instanceof NullConnector\n        );\n    }\n\n    /**\n     * Get the Socket ID for the connection.\n     */\n    socketId(): string | undefined {\n        return this.connector.socketId();\n    }\n\n    /**\n     * Register 3rd party request interceptiors. These are used to automatically\n     * send a connections socket id to a Laravel app with a X-Socket-Id header.\n     */\n    registerInterceptors(): void {\n        // TODO: This package is deprecated and we should remove it in a future version.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (typeof Vue !== \"undefined\" && Vue?.http) {\n            this.registerVueRequestInterceptor();\n        }\n\n        if (typeof axios === \"function\") {\n            this.registerAxiosRequestInterceptor();\n        }\n\n        if (typeof jQuery === \"function\") {\n            this.registerjQueryAjaxSetup();\n        }\n\n        if (typeof Turbo === \"object\") {\n            this.registerTurboRequestInterceptor();\n        }\n    }\n\n    /**\n     * Register a Vue HTTP interceptor to add the X-Socket-ID header.\n     */\n    registerVueRequestInterceptor(): void {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        Vue.http.interceptors.push(\n            (request: Record<any, any>, next: CallableFunction) => {\n                if (this.socketId()) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                    request.headers.set(\"X-Socket-ID\", this.socketId());\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                next();\n            },\n        );\n    }\n\n    /**\n     * Register an Axios HTTP interceptor to add the X-Socket-ID header.\n     */\n    registerAxiosRequestInterceptor(): void {\n        axios!.interceptors.request.use(\n            (config: InternalAxiosRequestConfig<any>) => {\n                if (this.socketId()) {\n                    config.headers[\"X-Socket-Id\"] = this.socketId();\n                }\n\n                return config;\n            },\n        );\n    }\n\n    /**\n     * Register jQuery AjaxPrefilter to add the X-Socket-ID header.\n     */\n    registerjQueryAjaxSetup(): void {\n        if (typeof jQuery.ajax != \"undefined\") {\n            jQuery.ajaxPrefilter(\n                (\n                    _options: any,\n                    _originalOptions: any,\n                    xhr: Record<any, any>,\n                ) => {\n                    if (this.socketId()) {\n                        xhr.setRequestHeader(\"X-Socket-Id\", this.socketId());\n                    }\n                },\n            );\n        }\n    }\n\n    /**\n     * Register the Turbo Request interceptor to add the X-Socket-ID header.\n     */\n    registerTurboRequestInterceptor(): void {\n        document.addEventListener(\n            \"turbo:before-fetch-request\",\n            (event: Record<any, any>) => {\n                event.detail.fetchOptions.headers[\"X-Socket-Id\"] =\n                    this.socketId();\n            },\n        );\n    }\n}\n\n/**\n * Export channel classes for TypeScript.\n */\nexport { Channel, Connector, type PresenceChannel };\n\nexport { EventFormatter } from \"./util\";\n\ntype CustomOmit<T, K extends PropertyKey> = {\n    [P in keyof T as Exclude<P, K>]: T[P];\n};\n\n/**\n * Specifies the broadcaster\n */\nexport type Broadcaster = {\n    reverb: {\n        connector: PusherConnector<\"reverb\">;\n        public: PusherChannel<\"reverb\">;\n        private: PusherPrivateChannel<\"reverb\">;\n        encrypted: PusherEncryptedPrivateChannel<\"reverb\">;\n        presence: PusherPresenceChannel<\"reverb\">;\n        options: GenericOptions<\"reverb\"> &\n            Partial<CustomOmit<PusherOptions<\"reverb\">, \"cluster\">>;\n    };\n    pusher: {\n        connector: PusherConnector<\"pusher\">;\n        public: PusherChannel<\"pusher\">;\n        private: PusherPrivateChannel<\"pusher\">;\n        encrypted: PusherEncryptedPrivateChannel<\"pusher\">;\n        presence: PusherPresenceChannel<\"pusher\">;\n        options: GenericOptions<\"pusher\"> & Partial<PusherOptions<\"pusher\">>;\n    };\n    ably: {\n        connector: PusherConnector<\"pusher\">;\n        public: PusherChannel<\"pusher\">;\n        private: PusherPrivateChannel<\"pusher\">;\n        encrypted: PusherEncryptedPrivateChannel<\"pusher\">;\n        presence: PusherPresenceChannel<\"pusher\">;\n        options: GenericOptions<\"ably\"> & Partial<PusherOptions<\"ably\">>;\n    };\n    \"socket.io\": {\n        connector: SocketIoConnector;\n        public: SocketIoChannel;\n        private: SocketIoPrivateChannel;\n        encrypted: never;\n        presence: SocketIoPresenceChannel;\n        options: GenericOptions<\"socket.io\">;\n    };\n    null: {\n        connector: NullConnector;\n        public: NullChannel;\n        private: NullPrivateChannel;\n        encrypted: NullEncryptedPrivateChannel;\n        presence: NullPresenceChannel;\n        options: GenericOptions<\"null\">;\n    };\n    function: {\n        connector: any;\n        public: any;\n        private: any;\n        encrypted: any;\n        presence: any;\n        options: GenericOptions<\"function\">;\n    };\n};\n\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nexport type BroadcastDriver = Exclude<keyof Broadcaster, \"function\">;\n\ntype GenericOptions<TBroadcaster extends keyof Broadcaster> = {\n    /**\n     * The broadcast connector.\n     */\n    broadcaster: TBroadcaster extends \"function\"\n        ? Constructor<InstanceType<Broadcaster[TBroadcaster][\"connector\"]>>\n        : TBroadcaster;\n\n    auth?: {\n        headers: Record<string, string>;\n    };\n    authEndpoint?: string;\n    userAuthentication?: {\n        endpoint: string;\n        headers: Record<string, string>;\n    };\n    csrfToken?: string | null;\n    bearerToken?: string | null;\n    host?: string | null;\n    key?: string | null;\n    namespace?: string | false;\n    withoutInterceptors?: boolean;\n\n    [key: string]: any;\n};\n\nexport type EchoOptions<TBroadcaster extends keyof Broadcaster> =\n    Broadcaster[TBroadcaster][\"options\"];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}